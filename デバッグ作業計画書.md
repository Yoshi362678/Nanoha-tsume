# 詰将棋エンジン デバッグ作業計画書

## 🎯 デバッグ目標
- 詰み判定の精度向上
- 合駒生成の不具合修正
- パフォーマンスの最適化
- アルゴリズムの動作確認

## 📋 事前準備

### 1. デバッグ環境セットアップ
```bash
# ファイルの場所確認
# C:\Users\user\Downloads\nanoha_tsume\Nanoha-tsume.html

# ブラウザで開く
# Chrome/Edge/Firefox等の開発者ツールを使用
```

### 2. 必要なツール
- **ブラウザ開発者ツール** (F12)
- **コンソール** (Console タブ)
- **Sources** (デバッガー)
- **Application** (LocalStorage確認)

## 🔍 デバッグ手順

### Phase 1: 基本動作確認 (30分)

#### ステップ1-1: UI動作テスト
1. `Nanoha-tsume.html`をブラウザで開く
2. 開発者ツール (F12) を開く
3. コンソールにエラーがないか確認

**チェック項目:**
- [ ] 盤面が正しく表示される
- [ ] 駒の配置ができる
- [ ] 持ち駒の追加/削除ができる
- [ ] 例題読込が動作する

#### ステップ1-2: テストケース実行
```javascript
// コンソールで実行
// 1手詰めテスト
engine.decodePosition("△５一玉 ▲６二金 ▲５二金");
engine.solveTsume();

// 結果確認: ▲４二金で詰みのはず
```

### Phase 2: 詳細デバッグ (60分)

#### ステップ2-1: 探索アルゴリズムの確認
```javascript
// デバッグ用ログを追加 (search()関数内)
search(depth, isSente) {
    console.log(`[DEBUG] 深さ:${depth} 手番:${isSente ? '先手' : '後手'}`);
    // 既存コード...
}

// 王手判定の確認
isCheck(side) {
    const result = /* 既存の判定処理 */;
    console.log(`[DEBUG] ${side}の王手判定: ${result}`);
    return result;
}
```

#### ステップ2-2: 手生成の検証
```javascript
// 王手生成のテスト
const checks = engine.generateChecks();
console.log('生成された王手:', checks.map(m => engine.formatMove(m)));

// 王手回避の確認
const evasions = engine.generateEvasions();  
console.log('王手回避手:', evasions.map(m => engine.formatMove(m)));
```

### Phase 3: 問題修正 (90分)

#### 優先度1: 詰み判定の修正
**問題箇所:** `search()`関数 (613-677行)
```javascript
// 現在の問題
// - 後手番で王手でない場合の処理
// - すべての回避手をチェックしきれていない可能性

// 修正ポイント
if (!isCheck) return [];  // この部分を詳細確認
```

#### 優先度2: 合駒生成の実装
**問題箇所:** `generateEvasions()`関数 (727-820行)
```javascript
// TODO: 持ち駒からの合駒打ちを追加
// 3. 合駒（飛び駒による王手の場合）の部分に以下を追加：

// 後手の持ち駒で合駒
for (const [piece, count] of Object.entries(this.mochiGoma.gote)) {
    if (count > 0 && this.canDrop(piece, r, c)) {
        const move = {
            type: 'drop',
            piece: piece,  
            to: blockPos
        };
        evasions.push(move);
    }
}
```

#### 優先度3: パフォーマンス改善
```javascript
// ハッシュ表の効率化
// 置換表のサイズ制限
if (this.hashTable.size > 10000) {
    this.hashTable.clear();
}

// 無効手の早期カット
// 明らかに無意味な手を除外
```

## 🧪 テスト計画

### 基本テストケース
```javascript
// Test 1: 1手詰め確認
test1 = "△５一玉 ▲６二金 ▲５二金";
// 期待結果: ▲４二金 で詰み

// Test 2: 3手詰め確認  
test2 = "△５二玉 △４二歩 ▲５五飛 ▲持金1";
// 期待結果: ▲５三金打→△４一玉→▲４二金

// Test 3: 不詰み確認
test3 = "△２二玉 △２一銀 △２三歩 △１三歩 ▲４四龍 ▲５五角";
// 期待結果: 不詰み
```

### 実行手順
```javascript
// 各テストの実行
function runTest(testCase, expected) {
    console.log(`=== テスト開始: ${testCase} ===`);
    engine.decodePosition(testCase);
    const startTime = Date.now();
    engine.solveTsume();
    const elapsed = Date.now() - startTime;
    console.log(`実行時間: ${elapsed}ms`);
    console.log(`期待結果: ${expected}`);
    console.log('=== テスト終了 ===\n');
}
```

## 🚨 注意点とトラブルシューティング

### よくある問題
1. **無限ループ**: ノード数が100,000に達する
   - 原因: 循環参照、ハッシュ表の不具合
   - 対策: デバッグログで探索パスを確認

2. **誤った詰み判定**: 詰むはずなのに不詰み
   - 原因: 王手回避手の見落とし
   - 対策: generateEvasions()の全パターンテスト

3. **パフォーマンス悪化**: 探索が遅い
   - 原因: 枝刈りの不足
   - 対策: 無駄手の早期カット

### デバッグ用コンソールコマンド
```javascript
// エンジンの状態確認
console.log('現在の盤面:', engine.board);
console.log('持ち駒:', engine.mochiGoma);
console.log('ハッシュ表サイズ:', engine.hashTable.size);

// 特定位置の詳細分析
engine.analyzePosition = function(pos) {
    const [row, col] = humanToInternal(pos);
    console.log(`${pos}の駒:`, this.board[row][col]);
    console.log(`${pos}への攻撃駒:`, this.getAttackers(row, col, 'sente'));
};
```

## 📊 作業スケジュール

| 時間 | 作業内容 | 成果物 |
|------|----------|--------|
| 0-30分 | 基本動作確認 | 動作確認レポート |
| 30-90分 | 詳細デバッグ | バグ特定リスト |
| 90-180分 | 問題修正 | 修正されたコード |
| 180-210分 | 総合テスト | テスト結果レポート |

## ✅ 完了チェックリスト

### Phase 1 完了条件
- [ ] UI操作が正常動作
- [ ] 基本テストケース実行完了
- [ ] コンソールエラーなし

### Phase 2 完了条件  
- [ ] 探索アルゴリズムの動作確認
- [ ] 手生成の検証完了
- [ ] 問題箇所の特定

### Phase 3 完了条件
- [ ] 詰み判定の修正
- [ ] 合駒生成の実装
- [ ] パフォーマンス改善
- [ ] 全テストケースの成功

## 📝 成果物

1. **デバッグレポート**: 発見した問題と修正内容
2. **テスト結果**: 各テストケースの実行結果
3. **改良版コード**: 修正されたNanoha-tsume.html
4. **パフォーマンス分析**: 実行速度の改善状況