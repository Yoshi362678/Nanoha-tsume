<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>è©°å°†æ£‹ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆãªã®ã¯è©°ã‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }

      .container {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        padding: 30px;
        max-width: 1200px;
        width: 100%;
      }

      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
        font-size: 2em;
      }

      .main-content {
        display: flex;
        gap: 30px;
        flex-wrap: wrap;
        justify-content: center;
      }

      .board-section {
        flex: 1;
        min-width: 400px;
      }

      .board-container {
        position: relative;
        background: #f5deb3;
        border: 3px solid #8b4513;
        border-radius: 5px;
        padding: 30px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      }

      .coordinates {
        position: absolute;
        font-weight: bold;
        color: #8b4513;
        font-size: 14px;
      }

      .coord-top {
        top: 5px;
        left: 50%;
        transform: translateX(-50%);
      }

      .coord-right {
        right: 5px;
        top: 50%;
        transform: translateY(-50%);
      }

      #board {
        display: grid;
        grid-template-columns: repeat(9, 50px);
        grid-template-rows: repeat(9, 50px);
        gap: 1px;
        background: #8b4513;
        border: 2px solid #654321;
      }

      .cell {
        background: #faebd7;
        border: 1px solid #d2691e;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        position: relative;
        transition: all 0.3s ease;
      }

      .cell:hover {
        background: #ffe4b5;
        transform: scale(1.05);
      }

      .cell.selected {
        background: #98fb98;
        box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.5);
      }

      .cell.possible-move {
        background: #87ceeb;
        box-shadow: inset 0 0 10px rgba(0, 100, 255, 0.3);
      }

      .piece {
        font-size: 28px;
        font-weight: bold;
        user-select: none;
        transition: transform 0.2s ease;
      }

      .piece:hover {
        transform: scale(1.1);
      }

      .piece.sente {
        color: #000;
      }

      .piece.gote {
        color: #dc143c;
        transform: rotate(180deg);
      }

      .controls {
        flex: 1;
        min-width: 350px;
      }

      .control-section {
        background: #f9f9f9;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      }

      .control-section h2 {
        color: #555;
        margin-bottom: 15px;
        font-size: 1.3em;
      }

      .piece-selector {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
        margin-bottom: 15px;
      }

      .piece-btn {
        padding: 10px;
        border: 2px solid #ddd;
        background: white;
        border-radius: 5px;
        cursor: pointer;
        font-size: 20px;
        transition: all 0.3s ease;
      }

      .piece-btn:hover {
        background: #f0f0f0;
        transform: translateY(-2px);
        box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
      }

      .piece-btn.selected {
        background: #4caf50;
        color: white;
        border-color: #45a049;
      }

      .side-selector {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }

      .side-btn {
        flex: 1;
        padding: 10px;
        border: 2px solid #ddd;
        background: white;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .side-btn.selected {
        background: #2196f3;
        color: white;
        border-color: #1976d2;
      }

      .action-buttons {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      button {
        padding: 12px 24px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        transition: all 0.3s ease;
        flex: 1;
        min-width: 120px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-secondary {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
      }

      .btn-danger {
        background: linear-gradient(135deg, #fc466b 0%, #3f5efb 100%);
        color: white;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
      }

      .status {
        margin-top: 20px;
        padding: 15px;
        background: #e8f5e9;
        border-left: 4px solid #4caf50;
        border-radius: 5px;
        font-weight: bold;
      }

      .status.error {
        background: #ffebee;
        border-left-color: #f44336;
      }

      .status.success {
        background: #e8f5e9;
        border-left-color: #4caf50;
      }

      .status.processing {
        background: #e3f2fd;
        border-left-color: #2196f3;
      }

      .move-list {
        max-height: 200px;
        overflow-y: auto;
        padding: 10px;
        background: white;
        border: 1px solid #ddd;
        border-radius: 5px;
        margin-top: 10px;
      }

      .move-item {
        padding: 5px;
        margin: 2px 0;
        background: #f5f5f5;
        border-radius: 3px;
        cursor: pointer;
        transition: background 0.3s ease;
      }

      .move-item:hover {
        background: #e0e0e0;
      }

      .stats {
        margin-top: 10px;
        font-size: 0.9em;
        color: #666;
      }

      @media (max-width: 768px) {
        .main-content {
          flex-direction: column;
        }

        #board {
          grid-template-columns: repeat(9, 40px);
          grid-template-rows: repeat(9, 40px);
        }

        .piece {
          font-size: 24px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ğŸ¯ è©°å°†æ£‹ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆãªã®ã¯è©°ã‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰</h1>

      <div class="main-content">
        <div class="board-section">
          <div class="board-container">
            <div class="coordinates coord-top">â–¼å…ˆæ‰‹</div>
            <div class="coordinates coord-right">9 8 7 6 5 4 3 2 1</div>
            <div id="board"></div>
          </div>
        </div>

        <div class="controls">
          <div class="control-section">
            <h2>ğŸ“‹ é§’é…ç½®ãƒ¢ãƒ¼ãƒ‰</h2>

            <div class="side-selector">
              <button class="side-btn selected" data-side="sente">
                â˜— å…ˆæ‰‹ï¼ˆæ”»æ–¹ï¼‰
              </button>
              <button class="side-btn" data-side="gote">â˜– å¾Œæ‰‹ï¼ˆç‰æ–¹ï¼‰</button>
            </div>

            <div class="piece-selector">
              <button class="piece-btn" data-piece="ç‰">ç‰</button>
              <button class="piece-btn" data-piece="é£›">é£›</button>
              <button class="piece-btn" data-piece="è§’">è§’</button>
              <button class="piece-btn" data-piece="é‡‘">é‡‘</button>
              <button class="piece-btn" data-piece="éŠ€">éŠ€</button>
              <button class="piece-btn" data-piece="æ¡‚">æ¡‚</button>
              <button class="piece-btn" data-piece="é¦™">é¦™</button>
              <button class="piece-btn" data-piece="æ­©">æ­©</button>
              <button class="piece-btn" data-piece="é¾">é¾</button>
              <button class="piece-btn" data-piece="é¦¬">é¦¬</button>
              <button class="piece-btn" data-piece="å…¨">å…¨</button>
              <button class="piece-btn" data-piece="åœ­">åœ­</button>
              <button class="piece-btn" data-piece="æ">æ</button>
              <button class="piece-btn" data-piece="ã¨">ã¨</button>
              <button class="piece-btn" data-piece="å‰Šé™¤">Ã—</button>
            </div>

            <div style="margin-top: 15px">
              <h3>æŒã¡é§’ï¼ˆå…ˆæ‰‹ã®ã¿ï¼‰</h3>
              <div
                id="mochiGomaDisplay"
                style="
                  padding: 10px;
                  background: white;
                  border-radius: 5px;
                  min-height: 40px;
                "
              >
                <div>å…ˆæ‰‹: <span id="senteMochi">ãªã—</span></div>
                <div style="color: #888; font-size: 0.9em">
                  â€»è©°å°†æ£‹ã§ã¯å…ˆæ‰‹ã®æŒé§’ä»¥å¤–ã¯å…¨ã¦å¾Œæ‰‹ãŒæŒã£ã¦ã„ã¾ã™
                </div>
              </div>
              <div style="margin-top: 10px">
                <label
                  >å…ˆæ‰‹ã®æŒé§’ã«è¿½åŠ :
                  <select id="mochiPiece" style="padding: 5px">
                    <option value="">é¸æŠ</option>
                    <option value="é£›">é£›</option>
                    <option value="è§’">è§’</option>
                    <option value="é‡‘">é‡‘</option>
                    <option value="éŠ€">éŠ€</option>
                    <option value="æ¡‚">æ¡‚</option>
                    <option value="é¦™">é¦™</option>
                    <option value="æ­©">æ­©</option>
                  </select>
                </label>
                <button onclick="addMochiGoma()" style="padding: 5px 10px">
                  è¿½åŠ 
                </button>
                <button
                  onclick="clearSenteMochi()"
                  style="padding: 5px 10px; background: #ff6b6b; color: white"
                >
                  ã‚¯ãƒªã‚¢
                </button>
              </div>
            </div>
          </div>

          <div class="control-section">
            <h2>ğŸ® æ“ä½œ</h2>
            <div class="action-buttons">
              <button class="btn-primary" onclick="solveTsume()">
                è©°ã¿ã‚’è§£ã
              </button>
              <button class="btn-secondary" onclick="clearBoard()">
                ç›¤é¢ã‚¯ãƒªã‚¢
              </button>
              <button class="btn-secondary" onclick="loadSampleProblem()">
                ä¾‹é¡Œã‚’èª­è¾¼
              </button>
            </div>
            <div style="margin-top: 15px">
              <h3>ğŸ’¾ é…ç½®ã®ä¿å­˜ãƒ»èª­è¾¼</h3>
              <div style="display: flex; gap: 10px; margin-bottom: 10px">
                <button onclick="savePosition()" style="flex: 1; padding: 8px">
                  ç¾åœ¨ã®é…ç½®ã‚’ä¿å­˜
                </button>
                <button
                  onclick="showSavedPositions()"
                  style="flex: 1; padding: 8px"
                >
                  ä¿å­˜ã—ãŸé…ç½®ã‚’è¡¨ç¤º
                </button>
              </div>
              <div id="savedPositions" style="display: none; margin-top: 10px">
                <select
                  id="positionSelect"
                  style="width: 100%; padding: 5px; margin-bottom: 10px"
                >
                  <option value="">ä¿å­˜ã—ãŸé…ç½®ã‚’é¸æŠ</option>
                </select>
                <div style="display: flex; gap: 10px">
                  <button
                    onclick="loadPosition()"
                    style="flex: 1; padding: 8px"
                  >
                    èª­è¾¼
                  </button>
                  <button
                    onclick="deletePosition()"
                    style="
                      flex: 1;
                      padding: 8px;
                      background: #ff6b6b;
                      color: white;
                    "
                  >
                    å‰Šé™¤
                  </button>
                </div>
              </div>
              <div style="margin-top: 10px">
                <h4>é…ç½®ã‚³ãƒ¼ãƒ‰</h4>
                <textarea
                  id="positionCode"
                  style="
                    width: 100%;
                    height: 60px;
                    font-family: monospace;
                    font-size: 12px;
                  "
                  placeholder="é…ç½®ã‚³ãƒ¼ãƒ‰ã‚’ã“ã“ã«è²¼ã‚Šä»˜ã‘ã¦èª­ã¿è¾¼ã‚€ã“ã¨ã‚‚ã§ãã¾ã™"
                ></textarea>
                <div style="display: flex; gap: 10px; margin-top: 5px">
                  <button
                    onclick="exportPosition()"
                    style="flex: 1; padding: 8px"
                  >
                    ç¾åœ¨ã®é…ç½®ã‚’ã‚³ãƒ”ãƒ¼
                  </button>
                  <button
                    onclick="importPosition()"
                    style="flex: 1; padding: 8px"
                  >
                    ã‚³ãƒ¼ãƒ‰ã‹ã‚‰èª­è¾¼
                  </button>
                </div>
              </div>
            </div>
          </div>

          <div class="control-section">
            <h2>ğŸ“Š çŠ¶æ…‹</h2>
            <div id="status" class="status">
              é§’ã‚’é…ç½®ã—ã¦ãã ã•ã„ï¼ˆåº§æ¨™ä¾‹ï¼šï¼•ä¸€ç‰ï¼‰
            </div>
            <div id="stats" class="stats"></div>
            <div id="moveList" class="move-list" style="display: none"></div>
            <div style="margin-top: 10px">
              <label>
                <input
                  type="checkbox"
                  id="debugMode"
                  onchange="toggleDebugMode()"
                />
                ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰
              </label>
            </div>
            <div
              id="debugOutput"
              style="
                display: none;
                margin-top: 10px;
                padding: 10px;
                background: #f0f0f0;
                border-radius: 5px;
                font-family: monospace;
                font-size: 12px;
                max-height: 200px;
                overflow-y: auto;
              "
            ></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // åº§æ¨™å¤‰æ›ï¼ˆäººé–“è¡¨è¨˜ã‚’åŸºæº–ã«ï¼‰
      const SUJI_MAP = {
        "ï¼™": 0,
        "ï¼˜": 1,
        "ï¼—": 2,
        "ï¼–": 3,
        "ï¼•": 4,
        "ï¼”": 5,
        "ï¼“": 6,
        "ï¼’": 7,
        "ï¼‘": 8,
      };
      const DAN_MAP = {
        ä¸€: 0,
        äºŒ: 1,
        ä¸‰: 2,
        å››: 3,
        äº”: 4,
        å…­: 5,
        ä¸ƒ: 6,
        å…«: 7,
        ä¹: 8,
      };
      const SUJI_STR = ["ï¼™", "ï¼˜", "ï¼—", "ï¼–", "ï¼•", "ï¼”", "ï¼“", "ï¼’", "ï¼‘"];
      const DAN_STR = ["ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­", "ä¸ƒ", "å…«", "ä¹"];

      // äººé–“è¡¨è¨˜ã‹ã‚‰å†…éƒ¨åº§æ¨™ã¸
      function humanToInternal(humanPos) {
        if (!humanPos || humanPos.length !== 2) return null;
        const suji = SUJI_MAP[humanPos[0]];
        const dan = DAN_MAP[humanPos[1]];
        if (suji === undefined || dan === undefined) return null;
        return [dan, suji];
      }

      // å†…éƒ¨åº§æ¨™ã‹ã‚‰äººé–“è¡¨è¨˜ã¸
      function internalToHuman(row, col) {
        return SUJI_STR[col] + DAN_STR[row];
      }

      // è©°å°†æ£‹ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆãªã®ã¯è©°ã‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰
      class TsumeShogi {
        constructor() {
          this.board = Array(9)
            .fill(null)
            .map(() => Array(9).fill(null));
          this.currentSide = "sente";
          this.selectedPiece = null;
          this.solving = false;
          this.mochiGoma = { sente: {}, gote: {} };
          this.hashTable = new Map();
          this.nodeCount = 0;
          this.maxDepth = 25;  // 5æ‰‹è©°ã‚å¯¾å¿œã®ãŸã‚å¢—åŠ 
          this.maxNodes = 200000;  // ãƒãƒ¼ãƒ‰æ•°åˆ¶é™ã‚’å¢—åŠ 
          this.debugMode = false;
          this.startTime = null;
          this.timeLimit = 30000;  // 30ç§’ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
          this.positionHistory = [];  // å±€é¢å±¥æ­´ï¼ˆåƒæ—¥æ‰‹æ¤œå‡ºç”¨ï¼‰
          this.repetitionCount = new Map();  // åŒä¸€å±€é¢ã‚«ã‚¦ãƒ³ãƒˆ
          this.init();
        }

        init() {
          this.createBoard();
          this.setupEventListeners();
          this.updateStatus("é§’ã‚’é…ç½®ã—ã¦ãã ã•ã„");
        }

        createBoard() {
          const boardElement = document.getElementById("board");
          boardElement.innerHTML = "";

          for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
              const cell = document.createElement("div");
              cell.className = "cell";
              cell.dataset.row = row;
              cell.dataset.col = col;
              cell.onclick = () => this.cellClick(row, col);

              const pos = internalToHuman(row, col);
              cell.title = pos;

              boardElement.appendChild(cell);
            }
          }
        }

        setupEventListeners() {
          document.querySelectorAll(".piece-btn").forEach((btn) => {
            btn.onclick = () => {
              document
                .querySelectorAll(".piece-btn")
                .forEach((b) => b.classList.remove("selected"));
              btn.classList.add("selected");
              this.selectedPiece = btn.dataset.piece;
            };
          });

          document.querySelectorAll(".side-btn").forEach((btn) => {
            btn.onclick = () => {
              document
                .querySelectorAll(".side-btn")
                .forEach((b) => b.classList.remove("selected"));
              btn.classList.add("selected");
              this.currentSide = btn.dataset.side;
            };
          });
        }

        cellClick(row, col) {
          if (this.solving) return;

          if (this.selectedPiece === "å‰Šé™¤") {
            this.board[row][col] = null;
            this.updateBoard();
            return;
          }

          if (this.selectedPiece) {
            this.board[row][col] = {
              piece: this.selectedPiece,
              side: this.currentSide,
            };
            this.updateBoard();
          }
        }

        updateBoard() {
          const cells = document.querySelectorAll(".cell");
          cells.forEach((cell, index) => {
            const row = Math.floor(index / 9);
            const col = index % 9;
            const piece = this.board[row][col];

            if (piece) {
              cell.innerHTML = `<span class="piece ${piece.side}">${piece.piece}</span>`;
            } else {
              cell.innerHTML = "";
            }
          });
        }

        // ç›¤é¢ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–
        hashPosition() {
          let hash = "";
          for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
              const piece = this.board[row][col];
              if (piece) {
                hash += `${internalToHuman(row, col)}${piece.piece}${
                  piece.side[0]
                }`;
              }
            }
          }
          for (const [piece, count] of Object.entries(this.mochiGoma.sente)) {
            hash += `S${piece}${count}`;
          }
          return hash;
        }

        // ãªã®ã¯è©°ã‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ãƒ¡ã‚¤ãƒ³
        solveTsume() {
          this.solving = true;
          this.nodeCount = 0;
          this.hashTable.clear();
          this.positionHistory = [];
          this.repetitionCount.clear();
          this.startTime = Date.now();
          this.updateStatus("æ¢ç´¢ä¸­...", "processing");

          // å¾Œæ‰‹ç‰ã®ä½ç½®ç¢ºèª
          let goteKingPos = null;
          for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
              const piece = this.board[row][col];
              if (piece && piece.piece === "ç‰" && piece.side === "gote") {
                goteKingPos = internalToHuman(row, col);
                break;
              }
            }
          }

          if (!goteKingPos) {
            this.updateStatus("å¾Œæ‰‹ã®ç‰ã‚’é…ç½®ã—ã¦ãã ã•ã„", "error");
            this.solving = false;
            return;
          }

          // éåŒæœŸã§å®Ÿè¡Œ
          setTimeout(() => {
            try {
              const startTime = Date.now();
              let solution = null;

              // åå¾©æ·±åŒ–
              for (let depth = 1; depth <= this.maxDepth; depth++) {
                if (this.debugMode) {
                  this.debugLog(`æ·±ã• ${depth} ã®æ¢ç´¢é–‹å§‹`);
                }
                const result = this.search(depth, true);
                if (result) {
                  solution = result;
                  if (this.debugMode) {
                    this.debugLog(`è©°ã¿ã‚’ç™ºè¦‹ï¼ ${result.length}æ‰‹è©°ã‚`);
                  }
                  break;
                }
                // ç„¡é™ãƒ«ãƒ¼ãƒ—å¯¾ç­–ï¼ˆå¼·åŒ–ç‰ˆï¼‰
                if (this.nodeCount > this.maxNodes) {
                  if (this.debugMode) {
                    this.debugLog(`ãƒãƒ¼ãƒ‰æ•°åˆ¶é™ (${this.maxNodes}) ã«åˆ°é”`);
                  }
                  break;
                }
                
                // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒã‚§ãƒƒã‚¯
                if (Date.now() - startTime > this.timeLimit) {
                  if (this.debugMode) {
                    this.debugLog(`ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ (${this.timeLimit}ms) ã«åˆ°é”`);
                  }
                  break;
                }
              }

              const elapsed = Date.now() - startTime;

              if (solution) {
                this.updateStatus(
                  `è©°ã¿ã¾ã—ãŸï¼ ${solution.length}æ‰‹è©°ã‚`,
                  "success"
                );
                this.displayMoves(solution);
              } else {
                this.updateStatus("è©°ã¿ã¾ã›ã‚“", "error");
              }

              document.getElementById("stats").innerHTML =
                `æ¢ç´¢ãƒãƒ¼ãƒ‰æ•°: ${this.nodeCount.toLocaleString()} | ` +
                `æ™‚é–“: ${(elapsed / 1000).toFixed(2)}ç§’`;
            } catch (error) {
              console.error("ã‚¨ãƒ©ãƒ¼:", error);
              this.updateStatus("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ", "error");
            } finally {
              this.solving = false;
            }
          }, 10);
        }

        // æ¢ç´¢æœ¬ä½“
        search(depth, isSente, visitedPositions = new Set()) {
          if (depth === 0) return null;
          this.nodeCount++;
          
          // ãƒãƒ¼ãƒ‰æ•°ãƒã‚§ãƒƒã‚¯
          if (this.nodeCount > this.maxNodes) {
            return null;
          }
          
          // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒã‚§ãƒƒã‚¯
          if (this.startTime && Date.now() - this.startTime > this.timeLimit) {
            return null;
          }

          // ãƒãƒƒã‚·ãƒ¥è¡¨ç¢ºèª
          const hash = this.hashPosition();
          
          // åƒæ—¥æ‰‹ãƒã‚§ãƒƒã‚¯ï¼ˆåŒä¸€å±€é¢3å›ã§ç„¡åŠ¹ï¼‰
          if (visitedPositions.has(hash)) {
            if (this.debugMode) {
              this.debugLog(`åƒæ—¥æ‰‹æ¤œå‡º: ${hash.substring(0, 20)}...`);
            }
            return null;
          }
          
          const cached = this.hashTable.get(hash);
          if (cached && cached.depth >= depth) {
            return cached.result;
          }
          
          // ç¾åœ¨ã®å±€é¢ã‚’è¨ªå•æ¸ˆã¿ã«è¿½åŠ 
          const newVisited = new Set(visitedPositions);
          newVisited.add(hash);

          // ç¾åœ¨ã®çŠ¶æ…‹ç¢ºèª
          const isCheck = this.isCheck(isSente ? "gote" : "sente");

          if (isSente) {
            // å…ˆæ‰‹ç•ªï¼šç‹æ‰‹ã‚’ã‹ã‘ã‚‹
            const moves = this.generateChecks();

            if (this.debugMode && depth <= 3) {
              this.debugLog(`[å…ˆæ‰‹] ç”Ÿæˆã•ã‚ŒãŸç‹æ‰‹: ${moves.length}æ‰‹`);
              if (moves.length > 0 && moves.length <= 10) {
                this.debugLog(
                  `  ${moves.map((m) => this.formatMove(m)).join(", ")}`
                );
              }
            }

            for (const move of moves) {
              const backup = this.makeMove(move);
              const result = this.search(depth - 1, false, newVisited);
              this.unmakeMove(move, backup);

              if (result !== null) {
                const solution = [this.formatMove(move), ...result];
                this.hashTable.set(hash, { depth, result: solution });
                return solution;
              }
            }

            this.hashTable.set(hash, { depth, result: null });
            return null;
          } else {
            // å¾Œæ‰‹ç•ªï¼šç‹æ‰‹å›é¿
            if (!this.isCheck("gote")) {
              // ç‹æ‰‹ã•ã‚Œã¦ã„ãªã„å ´åˆã¯è©°ã¿ã§ã¯ãªã„
              if (this.debugMode) {
                this.debugLog(`å¾Œæ‰‹ãŒç‹æ‰‹ã•ã‚Œã¦ã„ãªã„ã®ã§è©°ã¿ã§ã¯ãªã„`);
              }
              return null;
            }

            const moves = this.generateEvasions();

            if (moves.length === 0) {
              if (this.debugMode) {
                this.debugLog(`å›é¿æ‰‹ãªã— - è©°ã¿ï¼`);
              }
              return []; // è©°ã¿
            }

            // ã™ã¹ã¦ã®å›é¿æ‰‹ã‚’è©¦ã™
            let bestSolution = null;

            for (const move of moves) {
              const backup = this.makeMove(move);

              // ç‹æ‰‹ãŒè§£é™¤ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
              if (!this.isCheck("gote")) {
                const result = this.search(depth - 1, true, newVisited);
                this.unmakeMove(move, backup);

                if (result === null) {
                  this.hashTable.set(hash, { depth, result: null });
                  return null; // ã“ã®æ‰‹ã§é€ƒã’ã‚‰ã‚Œã‚‹
                }
                // ã“ã®å›é¿æ‰‹ã§ã‚‚è©°ã‚€ãªã‚‰è¨˜éŒ²ï¼ˆä¸€ç•ªçŸ­ã„æ‰‹é †ã‚’é¸ã¶ï¼‰
                if (!bestSolution || result.length < bestSolution.length - 1) {
                  bestSolution = [this.formatMove(move), ...result];
                }
              } else {
                this.unmakeMove(move, backup);
              }
            }

            // ã™ã¹ã¦ã®æ‰‹ã‚’è©¦ã—ãŸçµæœ
            if (bestSolution) {
              this.hashTable.set(hash, { depth, result: bestSolution });
              return bestSolution;
            }

            // ã™ã¹ã¦ã®æ‰‹ã§è©°ã‚€
            this.hashTable.set(hash, { depth, result: [] });
            return [];
          }
        }

        // ç‹æ‰‹ç”Ÿæˆ
        generateChecks() {
          const checks = [];

          // ç›¤ä¸Šã®é§’ã®ç§»å‹•
          for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
              const piece = this.board[row][col];
              if (piece && piece.side === "sente") {
                const moves = this.getPieceMoves(row, col, piece);

                for (const move of moves) {
                  const backup = this.makeMove(move);
                  if (this.isCheck("gote")) {
                    checks.push(move);
                  }
                  this.unmakeMove(move, backup);
                }
              }
            }
          }

          // æŒã¡é§’ã‚’æ‰“ã¤
          for (const [piece, count] of Object.entries(this.mochiGoma.sente)) {
            if (count > 0) {
              for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                  if (!this.board[row][col] && this.canDrop(piece, row, col)) {
                    const move = {
                      type: "drop",
                      piece: piece,
                      to: internalToHuman(row, col),
                    };

                    const backup = this.makeMove(move);
                    if (this.isCheck("gote")) {
                      checks.push(move);
                    }
                    this.unmakeMove(move, backup);
                  }
                }
              }
            }
          }

          return checks;
        }

        // ç‹æ‰‹å›é¿æ‰‹ç”Ÿæˆ
        generateEvasions() {
          const evasions = [];

          // ç‰ã‚’æ¢ã™
          let kingPos = null;
          for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
              const piece = this.board[row][col];
              if (piece && piece.piece === "ç‰" && piece.side === "gote") {
                kingPos = [row, col];
                break;
              }
            }
          }

          if (!kingPos) return evasions;

          if (this.debugMode) {
            this.debugLog(
              `å¾Œæ‰‹ç‰ã®ä½ç½®: ${internalToHuman(kingPos[0], kingPos[1])}`
            );
          }

          // 1. ç‰ã®ç§»å‹•
          const kingMoves = this.getKingMoves(kingPos[0], kingPos[1]);
          for (const move of kingMoves) {
            const backup = this.makeMove(move);
            // ç§»å‹•å¾Œã‚‚ç‹æ‰‹ã•ã‚Œã¦ã„ãªã„ã‹ç¢ºèª
            if (!this.isCheck("gote")) {
              evasions.push(move);
            }
            this.unmakeMove(move, backup);
          }

          // 2. ç‹æ‰‹ã—ã¦ã„ã‚‹é§’ã‚’å–ã‚‹
          const attackers = this.getAttackers(kingPos[0], kingPos[1], "sente");
          if (attackers.length === 1) {
            // ä¸¡ç‹æ‰‹ã§ãªã„å ´åˆã®ã¿
            const attacker = attackers[0];
            // å¾Œæ‰‹ã®é§’ã§å–ã‚Œã‚‹ã‹ç¢ºèª
            for (let row = 0; row < 9; row++) {
              for (let col = 0; col < 9; col++) {
                const piece = this.board[row][col];
                if (piece && piece.side === "gote" && piece.piece !== "ç‰") {
                  if (
                    this.canAttack(row, col, attacker[0], attacker[1], piece)
                  ) {
                    const move = {
                      type: "move",
                      from: internalToHuman(row, col),
                      to: internalToHuman(attacker[0], attacker[1]),
                      piece: piece.piece,
                      captured: this.board[attacker[0]][attacker[1]],
                    };
                    evasions.push(move);
                  }
                }
              }
            }
          }

          // 3. åˆé§’ï¼ˆé£›ã³é§’ã«ã‚ˆã‚‹ç‹æ‰‹ã®å ´åˆï¼‰
          if (attackers.length === 1) {
            const attacker = attackers[0];
            const attackPiece = this.board[attacker[0]][attacker[1]];

            if (this.debugMode) {
              this.debugLog(
                `ç‹æ‰‹ã—ã¦ã„ã‚‹é§’: ${attackPiece.piece} at ${internalToHuman(
                  attacker[0],
                  attacker[1]
                )}`
              );
            }

            // é£›ã³é§’ã«ã‚ˆã‚‹ç‹æ‰‹ã‹ç¢ºèª
            if (["é£›", "é¾", "è§’", "é¦¬", "é¦™"].includes(attackPiece.piece)) {
              if (this.debugMode) {
                this.debugLog(`é£›ã³é§’ã«ã‚ˆã‚‹ç‹æ‰‹ãªã®ã§åˆé§’ã‚’æ¤œè¨`);
              }
              // ç‹æ‰‹ã®ç·šä¸Šã®ãƒã‚¹ã‚’æ¢ã™
              const dr = Math.sign(kingPos[0] - attacker[0]);
              const dc = Math.sign(kingPos[1] - attacker[1]);

              let r = attacker[0] + dr;
              let c = attacker[1] + dc;

              while (r !== kingPos[0] || c !== kingPos[1]) {
                // ã“ã®ãƒã‚¹ã«åˆé§’ã§ãã‚‹ã‹
                const blockPos = internalToHuman(r, c);

                if (this.debugMode) {
                  this.debugLog(`  åˆé§’å€™è£œä½ç½®: ${blockPos}`);
                }

                // å¾Œæ‰‹ã®é§’ã‚’ç§»å‹•ã—ã¦åˆé§’
                for (let row = 0; row < 9; row++) {
                  for (let col = 0; col < 9; col++) {
                    const piece = this.board[row][col];
                    if (
                      piece &&
                      piece.side === "gote" &&
                      piece.piece !== "ç‰"
                    ) {
                      const moves = this.getPieceMoves(row, col, piece);
                      for (const move of moves) {
                        if (move.to === blockPos) {
                          evasions.push(move);
                        }
                      }
                    }
                  }
                }

                // åˆé§’ã‚’æ‰“ã¤ï¼ˆè©°å°†æ£‹ã§ã¯å¾Œæ‰‹ã¯æŒé§’ç„¡é™ï¼‰
                const allPieces = ["æ­©", "é¦™", "æ¡‚", "éŠ€", "é‡‘", "è§’", "é£›"];
                const [blockRow, blockCol] = humanToInternal(blockPos);

                // ç©ºããƒã‚¹ã‹ç¢ºèª
                if (!this.board[blockRow][blockCol]) {
                  for (const piece of allPieces) {
                    // äºŒæ­©ãƒã‚§ãƒƒã‚¯
                    if (piece === "æ­©") {
                      let hasPawn = false;
                      for (let r = 0; r < 9; r++) {
                        if (
                          this.board[r][blockCol] &&
                          this.board[r][blockCol].piece === "æ­©" &&
                          this.board[r][blockCol].side === "gote"
                        ) {
                          hasPawn = true;
                          break;
                        }
                      }
                      if (hasPawn) continue;
                    }

                    // è¡Œãæ‰€ãƒã‚§ãƒƒã‚¯
                    if ((piece === "æ­©" || piece === "é¦™") && blockRow === 8)
                      continue;
                    if (piece === "æ¡‚" && blockRow >= 7) continue;

                    const move = {
                      type: "drop",
                      piece: piece,
                      to: blockPos,
                      side: "gote",
                    };
                    evasions.push(move);
                  }
                }

                r += dr;
                c += dc;
              }
            }
          }

          if (this.debugMode) {
            this.debugLog(`ç”Ÿæˆã•ã‚ŒãŸå›é¿æ‰‹æ•°: ${evasions.length}`);
          }

          return evasions;
        }

        // ç‰¹å®šã®ãƒã‚¹ã‚’æ”»æ’ƒã—ã¦ã„ã‚‹é§’ã‚’å–å¾—
        getAttackers(targetRow, targetCol, attackerSide) {
          const attackers = [];

          for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
              const piece = this.board[row][col];
              if (piece && piece.side === attackerSide) {
                if (this.canAttack(row, col, targetRow, targetCol, piece)) {
                  attackers.push([row, col]);
                }
              }
            }
          }

          return attackers;
        }

        // é§’ã®å‹•ãç”Ÿæˆ
        getPieceMoves(row, col, piece) {
          const moves = [];
          const from = internalToHuman(row, col);
          const directions = this.getPieceDirections(piece.piece, piece.side);

          for (const dir of directions) {
            // é£›ã³é§’ã‹ã©ã†ã‹åˆ¤å®š
            const isRangedPiece = ["é£›", "é¾", "è§’", "é¦¬", "é¦™"].includes(
              piece.piece
            );
            const maxRange = isRangedPiece ? 8 : 1;

            for (let dist = 1; dist <= maxRange; dist++) {
              const newRow = row + dir.row * dist;
              const newCol = col + dir.col * dist;

              if (!this.isInBoard(newRow, newCol)) break;

              const target = this.board[newRow][newCol];
              if (target && target.side === piece.side) break;

              const to = internalToHuman(newRow, newCol);

              // æˆã‚Œã‚‹ã‹ã©ã†ã‹åˆ¤å®š
              const canProm = this.canPromote(
                piece.piece,
                row,
                newRow,
                piece.side
              );

              // å¿…ãšæˆã‚‰ãªã‘ã‚Œã°ãªã‚‰ãªã„ã‹åˆ¤å®š
              const mustProm =
                piece.side === "sente"
                  ? ((piece.piece === "æ­©" || piece.piece === "é¦™") &&
                      newRow === 0) ||
                    (piece.piece === "æ¡‚" && newRow <= 1)
                  : ((piece.piece === "æ­©" || piece.piece === "é¦™") &&
                      newRow === 8) ||
                    (piece.piece === "æ¡‚" && newRow >= 7);

              // å¼·åˆ¶æˆã‚Šã§ãªã‘ã‚Œã°ã€æˆã‚‰ãšã®æ‰‹ã‚’ç”Ÿæˆ
              if (!mustProm) {
                moves.push({
                  type: "move",
                  from: from,
                  to: to,
                  piece: piece.piece,
                  captured: target,
                });
              }

              // æˆã‚Œã‚‹å ´åˆã¯æˆã‚Šã®æ‰‹ã‚‚ç”Ÿæˆ
              if (canProm) {
                moves.push({
                  type: "move",
                  from: from,
                  to: to,
                  piece: piece.piece,
                  captured: target,
                  promote: true,
                });
              }

              // é§’ã‚’å–ã£ãŸã‚‰æ­¢ã¾ã‚‹
              if (target) break;
            }
          }

          return moves;
        }

        // ç‰ã®å‹•ã
        getKingMoves(row, col) {
          const moves = [];
          const from = internalToHuman(row, col);
          const dirs = [
            [-1, -1],
            [-1, 0],
            [-1, 1],
            [0, -1],
            [0, 1],
            [1, -1],
            [1, 0],
            [1, 1],
          ];

          for (const [dr, dc] of dirs) {
            const newRow = row + dr;
            const newCol = col + dc;
            if (this.isInBoard(newRow, newCol)) {
              const target = this.board[newRow][newCol];
              if (!target || target.side !== "gote") {
                moves.push({
                  type: "move",
                  from: from,
                  to: internalToHuman(newRow, newCol),
                  piece: "ç‰",
                  captured: target,
                });
              }
            }
          }

          return moves;
        }

        // é§’ã®æ–¹å‘å®šç¾©ï¼ˆç°¡ç•¥ç‰ˆï¼‰
        getPieceDirections(piece, side) {
          const mult = side === "sente" ? -1 : 1;
          const basicDirs = {
            æ­©: [{ row: mult, col: 0 }],
            é¦™: [{ row: mult, col: 0 }],
            æ¡‚: [
              { row: mult * 2, col: -1 },
              { row: mult * 2, col: 1 },
            ],
            éŠ€: [
              { row: mult, col: -1 },
              { row: mult, col: 0 },
              { row: mult, col: 1 },
              { row: -mult, col: -1 },
              { row: -mult, col: 1 },
            ],
            é‡‘: [
              { row: mult, col: -1 },
              { row: mult, col: 0 },
              { row: mult, col: 1 },
              { row: 0, col: -1 },
              { row: 0, col: 1 },
              { row: -mult, col: 0 },
            ],
            è§’: [
              { row: -1, col: -1 },
              { row: -1, col: 1 },
              { row: 1, col: -1 },
              { row: 1, col: 1 },
            ],
            é£›: [
              { row: -1, col: 0 },
              { row: 1, col: 0 },
              { row: 0, col: -1 },
              { row: 0, col: 1 },
            ],
            ç‰: [
              { row: -1, col: -1 },
              { row: -1, col: 0 },
              { row: -1, col: 1 },
              { row: 0, col: -1 },
              { row: 0, col: 1 },
              { row: 1, col: -1 },
              { row: 1, col: 0 },
              { row: 1, col: 1 },
            ],
            é¾: [
              { row: -1, col: 0 },
              { row: 1, col: 0 },
              { row: 0, col: -1 },
              { row: 0, col: 1 },
              { row: -1, col: -1 },
              { row: -1, col: 1 },
              { row: 1, col: -1 },
              { row: 1, col: 1 },
            ],
            é¦¬: [
              { row: -1, col: -1 },
              { row: -1, col: 1 },
              { row: 1, col: -1 },
              { row: 1, col: 1 },
              { row: -1, col: 0 },
              { row: 1, col: 0 },
              { row: 0, col: -1 },
              { row: 0, col: 1 },
            ],
          };

          // æˆé§’ã¯é‡‘ã®å‹•ã
          const goldMove = basicDirs["é‡‘"];
          basicDirs["ã¨"] = goldMove;
          basicDirs["æ"] = goldMove;
          basicDirs["åœ­"] = goldMove;
          basicDirs["å…¨"] = goldMove;

          return basicDirs[piece] || [];
        }

        // æ‰‹ã‚’å®Ÿè¡Œ
        makeMove(move) {
          const backup = {
            board: null,
            mochiGoma: JSON.parse(JSON.stringify(this.mochiGoma)),
          };

          if (move.type === "drop") {
            const [row, col] = humanToInternal(move.to);
            const side = move.side || "sente";
            this.board[row][col] = { piece: move.piece, side: side };
            // å…ˆæ‰‹ã®æŒé§’ã®ã¿ç®¡ç†ï¼ˆå¾Œæ‰‹ã¯ç„¡é™ï¼‰
            if (side === "sente" && this.mochiGoma.sente[move.piece]) {
              this.mochiGoma.sente[move.piece]--;
              if (this.mochiGoma.sente[move.piece] === 0) {
                delete this.mochiGoma.sente[move.piece];
              }
            }
          } else {
            const [fromRow, fromCol] = humanToInternal(move.from);
            const [toRow, toCol] = humanToInternal(move.to);

            backup.board = this.board[toRow][toCol];

            const movingPiece = this.board[fromRow][fromCol];
            if (move.promote) {
              this.board[toRow][toCol] = {
                piece: this.promotePiece(move.piece),
                side: movingPiece.side,
              };
            } else {
              this.board[toRow][toCol] = movingPiece;
            }
            this.board[fromRow][fromCol] = null;

            // é§’ã‚’å–ã£ãŸå ´åˆ
            if (backup.board) {
              const demoted = this.demotePiece(backup.board.piece);
              if (!this.mochiGoma.sente[demoted]) {
                this.mochiGoma.sente[demoted] = 0;
              }
              this.mochiGoma.sente[demoted]++;
            }
          }

          return backup;
        }

        // æ‰‹ã‚’æˆ»ã™
        unmakeMove(move, backup) {
          if (move.type === "drop") {
            const [row, col] = humanToInternal(move.to);
            this.board[row][col] = null;
          } else {
            const [fromRow, fromCol] = humanToInternal(move.from);
            const [toRow, toCol] = humanToInternal(move.to);

            this.board[fromRow][fromCol] = this.board[toRow][toCol];
            if (move.promote) {
              this.board[fromRow][fromCol].piece = move.piece;
            }
            this.board[toRow][toCol] = backup.board;
          }

          this.mochiGoma = backup.mochiGoma;
        }

        // ç‹æ‰‹åˆ¤å®š
        isCheck(side) {
          let kingPos = null;
          for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
              const piece = this.board[row][col];
              if (piece && piece.piece === "ç‰" && piece.side === side) {
                kingPos = [row, col];
                break;
              }
            }
          }

          if (!kingPos) return false;

          const enemySide = side === "sente" ? "gote" : "sente";

          // å„æ•µé§’ã‹ã‚‰æ”»æ’ƒã•ã‚Œã¦ã„ã‚‹ã‹
          for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
              const piece = this.board[row][col];
              if (piece && piece.side === enemySide) {
                if (this.canAttack(row, col, kingPos[0], kingPos[1], piece)) {
                  return true;
                }
              }
            }
          }

          return false;
        }

        // æ”»æ’ƒåˆ¤å®š
        canAttack(fromRow, fromCol, toRow, toCol, piece) {
          const dr = toRow - fromRow;
          const dc = toCol - fromCol;

          // åŒã˜ä½ç½®ãªã‚‰æ”»æ’ƒã§ããªã„
          if (dr === 0 && dc === 0) return false;

          const directions = this.getPieceDirections(piece.piece, piece.side);

          for (const dir of directions) {
            // æ¡‚é¦¬ã®ç‰¹æ®Šåˆ¤å®š
            if (piece.piece === "æ¡‚") {
              if (dir.row === dr && dir.col === dc) return true;
              continue;
            }

            // æ–¹å‘ãŒä¸€è‡´ã™ã‚‹ã‹ç¢ºèª
            if (dr === 0 && dc === 0) continue;

            // æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã®æ­£è¦åŒ–
            const dirNormR = dir.row === 0 ? 0 : dir.row / Math.abs(dir.row);
            const dirNormC = dir.col === 0 ? 0 : dir.col / Math.abs(dir.col);
            const moveNormR = dr === 0 ? 0 : dr / Math.abs(dr);
            const moveNormC = dc === 0 ? 0 : dc / Math.abs(dc);

            // æ–¹å‘ãŒä¸€è‡´ã—ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
            if (dirNormR !== moveNormR || dirNormC !== moveNormC) continue;

            // è·é›¢ã‚’è¨ˆç®—
            const dist = Math.max(Math.abs(dr), Math.abs(dc));

            // 1ãƒã‚¹ç§»å‹•ã®é§’
            const oneStepPieces = [
              "æ­©",
              "éŠ€",
              "é‡‘",
              "ç‰",
              "ã¨",
              "æ",
              "åœ­",
              "å…¨",
            ];
            if (oneStepPieces.includes(piece.piece)) {
              return dist === 1;
            }

            // é¾ã¨é¦¬ã®æ–œã‚1ãƒã‚¹
            if (
              piece.piece === "é¾" &&
              Math.abs(dr) === 1 &&
              Math.abs(dc) === 1
            ) {
              return true;
            }
            if (piece.piece === "é¦¬" && Math.abs(dr) + Math.abs(dc) === 1) {
              return true;
            }

            // é£›ã³é§’ã®å ´åˆã€é€”ä¸­ã«é§’ãŒãªã„ã‹ç¢ºèª
            const isRangedPiece = ["é£›", "é¾", "è§’", "é¦¬", "é¦™"].includes(
              piece.piece
            );
            if (isRangedPiece) {
              // é£›è»Šç³»ã¯ç›´ç·šç§»å‹•ã®ã¿
              if (
                (piece.piece === "é£›" || piece.piece === "é¾") &&
                dr !== 0 &&
                dc !== 0
              ) {
                continue;
              }
              // è§’ç³»ã¯æ–œã‚ç§»å‹•ã®ã¿
              if (
                (piece.piece === "è§’" || piece.piece === "é¦¬") &&
                Math.abs(dr) !== Math.abs(dc)
              ) {
                continue;
              }

              // é€”ä¸­ã®é§’ã‚’ãƒã‚§ãƒƒã‚¯
              for (let i = 1; i < dist; i++) {
                const checkRow = fromRow + dirNormR * i;
                const checkCol = fromCol + dirNormC * i;
                if (this.board[checkRow][checkCol]) {
                  return false;
                }
              }
              return true;
            }
          }

          return false;
        }

        // é§’ã‚’æ‰“ã¦ã‚‹ã‹
        canDrop(piece, row, col) {
          // äºŒæ­©ãƒã‚§ãƒƒã‚¯
          if (piece === "æ­©") {
            for (let r = 0; r < 9; r++) {
              if (
                this.board[r][col] &&
                this.board[r][col].piece === "æ­©" &&
                this.board[r][col].side === "sente"
              ) {
                return false;
              }
            }
          }

          // è¡Œãæ‰€ãƒã‚§ãƒƒã‚¯
          if ((piece === "æ­©" || piece === "é¦™") && row === 0) return false;
          if (piece === "æ¡‚" && row <= 1) return false;

          return true;
        }

        // æˆã‚Šåˆ¤å®š
        canPromote(piece, fromRow, toRow, side) {
          if (
            piece === "é‡‘" ||
            piece === "ç‰" ||
            piece === "ã¨" ||
            piece === "æ" ||
            piece === "åœ­" ||
            piece === "å…¨" ||
            piece === "é¦¬" ||
            piece === "é¾"
          ) {
            return false;
          }

          if (side === "sente") {
            return fromRow <= 2 || toRow <= 2;
          } else {
            return fromRow >= 6 || toRow >= 6;
          }
        }

        // é§’ã‚’æˆã‚‹
        promotePiece(piece) {
          const promoteMap = {
            æ­©: "ã¨",
            é¦™: "æ",
            æ¡‚: "åœ­",
            éŠ€: "å…¨",
            è§’: "é¦¬",
            é£›: "é¾",
          };
          return promoteMap[piece] || piece;
        }

        // é§’ã‚’æˆ»ã™
        demotePiece(piece) {
          const demoteMap = {
            ã¨: "æ­©",
            æ: "é¦™",
            åœ­: "æ¡‚",
            å…¨: "éŠ€",
            é¦¬: "è§’",
            é¾: "é£›",
          };
          return demoteMap[piece] || piece;
        }

        // æ‰‹ã®è¡¨ç¤º
        formatMove(move) {
          if (move.type === "drop") {
            return `â–²${move.to}${move.piece}æ‰“`;
          } else {
            const promote = move.promote ? "æˆ" : "";
            const capture = move.captured ? "Ã—" : "";
            return `â–²${move.to}${move.piece}${promote}${capture}(${move.from})`;
          }
        }

        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
        isInBoard(row, col) {
          return row >= 0 && row < 9 && col >= 0 && col < 9;
        }

        displayMoves(moves) {
          const moveList = document.getElementById("moveList");
          moveList.style.display = "block";
          moveList.innerHTML = "<h3>è©°ã¿æ‰‹é †</h3>";

          moves.forEach((move, index) => {
            const moveItem = document.createElement("div");
            moveItem.className = "move-item";
            moveItem.textContent = `${index + 1}. ${move}`;
            moveList.appendChild(moveItem);
          });
        }

        updateStatus(message, type = "") {
          const status = document.getElementById("status");
          status.textContent = message;
          status.className = "status " + type;
        }

        clearBoard() {
          this.board = Array(9)
            .fill(null)
            .map(() => Array(9).fill(null));
          this.mochiGoma = { sente: {}, gote: {} };
          this.updateBoard();
          this.updateMochiGomaDisplay();
          this.updateStatus("ç›¤é¢ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ");
          document.getElementById("moveList").style.display = "none";
          document.getElementById("stats").innerHTML = "";
        }

        updateMochiGomaDisplay() {
          const senteMochi = document.getElementById("senteMochi");

          const formatMochi = (mochi) => {
            if (Object.keys(mochi).length === 0) return "ãªã—";
            return Object.entries(mochi)
              .map(([piece, count]) => `${piece}${count > 1 ? count : ""}`)
              .join(" ");
          };

          senteMochi.textContent = formatMochi(this.mochiGoma.sente);
        }

        loadSampleProblem() {
          // 1æ‰‹è©°ã‚ã®ç°¡å˜ãªå•é¡Œ
          this.clearBoard();

          // ï¼•ä¸€ç‰
          const [r1, c1] = humanToInternal("ï¼•ä¸€");
          this.board[r1][c1] = { piece: "ç‰", side: "gote" };

          // ï¼–äºŒé‡‘
          const [r2, c2] = humanToInternal("ï¼–äºŒ");
          this.board[r2][c2] = { piece: "é‡‘", side: "sente" };

          // ï¼•äºŒé‡‘
          const [r3, c3] = humanToInternal("ï¼•äºŒ");
          this.board[r3][c3] = { piece: "é‡‘", side: "sente" };

          this.updateBoard();
          this.updateMochiGomaDisplay();
          this.updateStatus("1æ‰‹è©°ã‚ã®ä¾‹é¡Œã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ");
        }

        // é…ç½®ã‚’æ–‡å­—åˆ—ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
        encodePosition() {
          const pieces = [];

          // ç›¤ä¸Šã®é§’
          for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
              const piece = this.board[row][col];
              if (piece) {
                const pos = internalToHuman(row, col);
                const prefix = piece.side === "gote" ? "â–³" : "â–²";
                pieces.push(`${prefix}${pos}${piece.piece}`);
              }
            }
          }

          // æŒã¡é§’
          for (const [piece, count] of Object.entries(this.mochiGoma.sente)) {
            if (count > 0) {
              pieces.push(`â–²æŒ${piece}${count > 1 ? count : ""}`);
            }
          }

          return pieces.join(" ");
        }

        // æ–‡å­—åˆ—ã‹ã‚‰é…ç½®ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰
        decodePosition(code) {
          console.log("ãƒ‡ã‚³ãƒ¼ãƒ‰é–‹å§‹:", code);
          this.clearBoard();

          // ã‚¹ãƒšãƒ¼ã‚¹ã¾ãŸã¯ã‚«ãƒ³ãƒã§åˆ†å‰²
          const parts = code.trim().split(/[\s,]+/);
          console.log("åˆ†å‰²ã•ã‚ŒãŸãƒ‘ãƒ¼ãƒ„:", parts);

          for (const part of parts) {
            if (part.length < 3) {
              console.log("ã‚¹ã‚­ãƒƒãƒ—ï¼ˆçŸ­ã™ãã‚‹ï¼‰:", part);
              continue;
            }

            const prefix = part[0];
            const side = prefix === "â–³" ? "gote" : "sente";

            if (part.includes("æŒ")) {
              // æŒã¡é§’
              const match = part.match(/æŒ(.+?)(\d*)$/);
              if (match) {
                const piece = match[1];
                const count = match[2] ? parseInt(match[2]) : 1;
                console.log(`æŒã¡é§’: ${piece} x ${count}`);
                this.mochiGoma.sente[piece] = count;
              }
            } else {
              // ç›¤ä¸Šã®é§’
              const pos = part.substring(1, 3);
              const piece = part.substring(3);
              console.log(`ç›¤ä¸Š: ${pos} ã« ${side} ã® ${piece}`);

              const coords = humanToInternal(pos);
              if (coords) {
                const [row, col] = coords;
                this.board[row][col] = { piece, side };
              } else {
                console.error("åº§æ¨™å¤‰æ›å¤±æ•—:", pos);
              }
            }
          }

          this.updateBoard();
          this.updateMochiGomaDisplay();
          console.log("ãƒ‡ã‚³ãƒ¼ãƒ‰å®Œäº†");
        }

        // é…ç½®ã‚’ä¿å­˜
        saveToLocalStorage(name) {
          const saved = this.getSavedPositions();
          saved[name] = {
            code: this.encodePosition(),
            date: new Date().toLocaleString("ja-JP"),
          };
          localStorage.setItem("tsumePositions", JSON.stringify(saved));
        }

        // ä¿å­˜ã—ãŸé…ç½®ã‚’å–å¾—
        getSavedPositions() {
          const saved = localStorage.getItem("tsumePositions");
          return saved ? JSON.parse(saved) : {};
        }

        // é…ç½®ã‚’å‰Šé™¤
        deleteFromLocalStorage(name) {
          const saved = this.getSavedPositions();
          delete saved[name];
          localStorage.setItem("tsumePositions", JSON.stringify(saved));
        }
      }

      // ã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–
      const engine = new TsumeShogi();

      // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°
      function solveTsume() {
        engine.solveTsume();
      }

      function clearBoard() {
        engine.clearBoard();
      }

      function loadSampleProblem() {
        engine.loadSampleProblem();
      }

      function addMochiGoma() {
        const select = document.getElementById("mochiPiece");
        const piece = select.value;
        if (!piece) return;

        if (!engine.mochiGoma.sente[piece]) {
          engine.mochiGoma.sente[piece] = 0;
        }
        engine.mochiGoma.sente[piece]++;
        engine.updateMochiGomaDisplay();
        select.value = "";
      }

      function clearSenteMochi() {
        engine.mochiGoma.sente = {};
        engine.updateMochiGomaDisplay();
      }

      // é…ç½®ã®ä¿å­˜ãƒ»èª­è¾¼æ©Ÿèƒ½
      function savePosition() {
        const name = prompt("é…ç½®ã®åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š");
        if (name && name.trim()) {
          engine.saveToLocalStorage(name.trim());
          engine.updateStatus(`ã€Œ${name}ã€ã¨ã—ã¦ä¿å­˜ã—ã¾ã—ãŸ`);
          updatePositionSelect();
        }
      }

      function showSavedPositions() {
        const div = document.getElementById("savedPositions");
        div.style.display = div.style.display === "none" ? "block" : "none";
        if (div.style.display === "block") {
          updatePositionSelect();
        }
      }

      function updatePositionSelect() {
        const select = document.getElementById("positionSelect");
        const saved = engine.getSavedPositions();

        select.innerHTML = '<option value="">ä¿å­˜ã—ãŸé…ç½®ã‚’é¸æŠ</option>';

        for (const [name, data] of Object.entries(saved)) {
          const option = document.createElement("option");
          option.value = name;
          option.textContent = `${name} (${data.date})`;
          select.appendChild(option);
        }
      }

      function loadPosition() {
        const select = document.getElementById("positionSelect");
        const name = select.value;
        if (!name) {
          engine.updateStatus("é…ç½®ã‚’é¸æŠã—ã¦ãã ã•ã„", "error");
          return;
        }

        const saved = engine.getSavedPositions();
        console.log("ä¿å­˜ã•ã‚ŒãŸé…ç½®ä¸€è¦§:", saved);
        console.log("é¸æŠã•ã‚ŒãŸé…ç½®å:", name);

        if (saved[name]) {
          console.log("èª­ã¿è¾¼ã‚€é…ç½®ã‚³ãƒ¼ãƒ‰:", saved[name].code);
          try {
            engine.decodePosition(saved[name].code);
            engine.updateStatus(`ã€Œ${name}ã€ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
          } catch (error) {
            console.error("é…ç½®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
            engine.updateStatus("é…ç½®ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ", "error");
          }
        } else {
          engine.updateStatus("æŒ‡å®šã•ã‚ŒãŸé…ç½®ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", "error");
        }
      }

      function deletePosition() {
        const select = document.getElementById("positionSelect");
        const name = select.value;
        if (!name) return;

        if (confirm(`ã€Œ${name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
          engine.deleteFromLocalStorage(name);
          updatePositionSelect();
          engine.updateStatus(`ã€Œ${name}ã€ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`);
        }
      }

      function exportPosition() {
        const code = engine.encodePosition();
        const textarea = document.getElementById("positionCode");
        textarea.value = code;

        // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
        textarea.select();
        document.execCommand("copy");

        engine.updateStatus("é…ç½®ã‚³ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
      }

      function importPosition() {
        const textarea = document.getElementById("positionCode");
        const code = textarea.value.trim();

        if (code) {
          try {
            engine.decodePosition(code);
            engine.updateStatus("é…ç½®ã‚³ãƒ¼ãƒ‰ã‹ã‚‰èª­ã¿è¾¼ã¿ã¾ã—ãŸ");
          } catch (error) {
            console.error("é…ç½®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
            engine.updateStatus("é…ç½®ã‚³ãƒ¼ãƒ‰ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“", "error");
          }
        }
      }

      // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
      function toggleDebugMode() {
        const checkbox = document.getElementById("debugMode");
        const debugOutput = document.getElementById("debugOutput");
        engine.debugMode = checkbox.checked;

        if (engine.debugMode) {
          debugOutput.style.display = "block";
          debugOutput.innerHTML = "[DEBUG] ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹<br>";
        } else {
          debugOutput.style.display = "none";
          debugOutput.innerHTML = "";
        }
      }

      // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°é–¢æ•°ã‚’è¿½åŠ 
      engine.debugLog = function (message) {
        if (this.debugMode) {
          const debugOutput = document.getElementById("debugOutput");
          debugOutput.innerHTML += `[DEBUG] ${message}<br>`;
          debugOutput.scrollTop = debugOutput.scrollHeight;
          console.log("[DEBUG]", message);
        }
      };
    </script>
  </body>
</html>
