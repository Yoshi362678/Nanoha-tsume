<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è©°å°†æ£‹ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆãªã®ã¯è©°ã‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2em;
        }

        .main-content {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .board-section {
            flex: 1;
            min-width: 400px;
        }

        .board-container {
            position: relative;
            background: #f5deb3;
            border: 3px solid #8b4513;
            border-radius: 5px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .coordinates {
            position: absolute;
            font-weight: bold;
            color: #8b4513;
            font-size: 14px;
        }

        .coord-top {
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
        }

        .coord-right {
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
        }

        #board {
            display: grid;
            grid-template-columns: repeat(9, 50px);
            grid-template-rows: repeat(9, 50px);
            gap: 1px;
            background: #8b4513;
            border: 2px solid #654321;
        }

        .cell {
            background: #faebd7;
            border: 1px solid #d2691e;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
        }

        .cell:hover {
            background: #ffe4b5;
            transform: scale(1.05);
        }

        .cell.selected {
            background: #98fb98;
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .cell.possible-move {
            background: #87ceeb;
            box-shadow: inset 0 0 10px rgba(0, 100, 255, 0.3);
        }

        .piece {
            font-size: 28px;
            font-weight: bold;
            user-select: none;
            transition: transform 0.2s ease;
        }

        .piece:hover {
            transform: scale(1.1);
        }

        .piece.sente {
            color: #000;
        }

        .piece.gote {
            color: #dc143c;
            transform: rotate(180deg);
        }

        .controls {
            flex: 1;
            min-width: 350px;
        }

        .control-section {
            background: #f9f9f9;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .control-section h2 {
            color: #555;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .piece-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .piece-btn {
            padding: 10px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.3s ease;
        }

        .piece-btn:hover {
            background: #f0f0f0;
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
        }

        .piece-btn.selected {
            background: #4CAF50;
            color: white;
            border-color: #45a049;
        }

        .side-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .side-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .side-btn.selected {
            background: #2196F3;
            color: white;
            border-color: #1976D2;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 120px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #fc466b 0%, #3f5efb 100%);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            background: #e8f5e9;
            border-left: 4px solid #4CAF50;
            border-radius: 5px;
            font-weight: bold;
        }

        .status.error {
            background: #ffebee;
            border-left-color: #f44336;
        }

        .status.success {
            background: #e8f5e9;
            border-left-color: #4CAF50;
        }

        .status.processing {
            background: #e3f2fd;
            border-left-color: #2196F3;
        }

        .move-list {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-top: 10px;
        }

        .move-item {
            padding: 5px;
            margin: 2px 0;
            background: #f5f5f5;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .move-item:hover {
            background: #e0e0e0;
        }

        .stats {
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            #board {
                grid-template-columns: repeat(9, 40px);
                grid-template-rows: repeat(9, 40px);
            }
            
            .piece {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ è©°å°†æ£‹ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆãªã®ã¯è©°ã‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰</h1>
        
        <div class="main-content">
            <div class="board-section">
                <div class="board-container">
                    <div class="coordinates coord-top">â–¼å…ˆæ‰‹</div>
                    <div class="coordinates coord-right">9 8 7 6 5 4 3 2 1</div>
                    <div id="board"></div>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-section">
                    <h2>ğŸ“‹ é§’é…ç½®ãƒ¢ãƒ¼ãƒ‰</h2>
                    
                    <div class="side-selector">
                        <button class="side-btn selected" data-side="sente">â˜— å…ˆæ‰‹ï¼ˆæ”»æ–¹ï¼‰</button>
                        <button class="side-btn" data-side="gote">â˜– å¾Œæ‰‹ï¼ˆç‰æ–¹ï¼‰</button>
                    </div>
                    
                    <div class="piece-selector">
                        <button class="piece-btn" data-piece="ç‰">ç‰</button>
                        <button class="piece-btn" data-piece="é£›">é£›</button>
                        <button class="piece-btn" data-piece="è§’">è§’</button>
                        <button class="piece-btn" data-piece="é‡‘">é‡‘</button>
                        <button class="piece-btn" data-piece="éŠ€">éŠ€</button>
                        <button class="piece-btn" data-piece="æ¡‚">æ¡‚</button>
                        <button class="piece-btn" data-piece="é¦™">é¦™</button>
                        <button class="piece-btn" data-piece="æ­©">æ­©</button>
                        <button class="piece-btn" data-piece="é¾">é¾</button>
                        <button class="piece-btn" data-piece="é¦¬">é¦¬</button>
                        <button class="piece-btn" data-piece="å…¨">å…¨</button>
                        <button class="piece-btn" data-piece="åœ­">åœ­</button>
                        <button class="piece-btn" data-piece="æ">æ</button>
                        <button class="piece-btn" data-piece="ã¨">ã¨</button>
                        <button class="piece-btn" data-piece="å‰Šé™¤">Ã—</button>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <h3>æŒã¡é§’ï¼ˆå…ˆæ‰‹ã®ã¿ï¼‰</h3>
                        <div id="mochiGomaDisplay" style="padding: 10px; background: white; border-radius: 5px; min-height: 40px;">
                            <div>å…ˆæ‰‹: <span id="senteMochi">ãªã—</span></div>
                            <div style="color: #888; font-size: 0.9em;">â€»è©°å°†æ£‹ã§ã¯å…ˆæ‰‹ã®æŒé§’ä»¥å¤–ã¯å…¨ã¦å¾Œæ‰‹ãŒæŒã£ã¦ã„ã¾ã™</div>
                        </div>
                        <div style="margin-top: 10px;">
                            <label>å…ˆæ‰‹ã®æŒé§’ã«è¿½åŠ : 
                                <select id="mochiPiece" style="padding: 5px;">
                                    <option value="">é¸æŠ</option>
                                    <option value="é£›">é£›</option>
                                    <option value="è§’">è§’</option>
                                    <option value="é‡‘">é‡‘</option>
                                    <option value="éŠ€">éŠ€</option>
                                    <option value="æ¡‚">æ¡‚</option>
                                    <option value="é¦™">é¦™</option>
                                    <option value="æ­©">æ­©</option>
                                </select>
                            </label>
                            <button onclick="addMochiGoma()" style="padding: 5px 10px;">è¿½åŠ </button>
                            <button onclick="clearSenteMochi()" style="padding: 5px 10px; background: #ff6b6b; color: white;">ã‚¯ãƒªã‚¢</button>
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h2>ğŸ® æ“ä½œ</h2>
                    <div class="action-buttons">
                        <button class="btn-primary" onclick="solveTsume()">è©°ã¿ã‚’è§£ã</button>
                        <button class="btn-secondary" onclick="clearBoard()">ç›¤é¢ã‚¯ãƒªã‚¢</button>
                        <button class="btn-secondary" onclick="loadSampleProblem()">ä¾‹é¡Œã‚’ãƒ©ãƒ³ãƒ€ãƒ èª­è¾¼</button>
                    </div>
                    <div style="margin-top: 10px;">
                        <select id="problemSelect" style="width: 100%; padding: 8px; margin-bottom: 5px;">
                            <option value="">ä¾‹é¡Œã‚’é¸æŠ</option>
                            <option value="0">1æ‰‹è©°ã‚ï¼ˆåŸºæœ¬ï¼‰</option>
                            <option value="1">3æ‰‹è©°ã‚ï¼ˆæŒé§’ä½¿ç”¨ï¼‰</option>
                            <option value="2">3æ‰‹è©°ã‚ï¼ˆåˆé§’å•é¡Œï¼‰</option>
                            <option value="3">ä¸è©°ã¿ï¼ˆåˆé§’ã§é€ƒã‚Œã‚‹ï¼‰</option>
                            <option value="4">1æ‰‹è©°ã‚ï¼ˆé ­é‡‘ï¼‰</option>
                            <option value="5">3æ‰‹è©°ã‚ï¼ˆé£›è»Šã®åˆ©ãï¼‰</option>
                        </select>
                        <button onclick="loadSpecificProblem()" style="width: 100%; padding: 8px;">é¸æŠã—ãŸä¾‹é¡Œã‚’èª­è¾¼</button>
                    </div>
                    <div style="margin-top: 15px;">
                        <h3>ğŸ’¾ é…ç½®ã®ä¿å­˜ãƒ»èª­è¾¼</h3>
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <button onclick="savePosition()" style="flex: 1; padding: 8px;">ç¾åœ¨ã®é…ç½®ã‚’ä¿å­˜</button>
                            <button onclick="showSavedPositions()" style="flex: 1; padding: 8px;">ä¿å­˜ã—ãŸé…ç½®ã‚’è¡¨ç¤º</button>
                        </div>
                        <div id="savedPositions" style="display: none; margin-top: 10px;">
                            <select id="positionSelect" style="width: 100%; padding: 5px; margin-bottom: 10px;">
                                <option value="">ä¿å­˜ã—ãŸé…ç½®ã‚’é¸æŠ</option>
                            </select>
                            <div style="display: flex; gap: 10px;">
                                <button onclick="loadPosition()" style="flex: 1; padding: 8px;">èª­è¾¼</button>
                                <button onclick="deletePosition()" style="flex: 1; padding: 8px; background: #ff6b6b; color: white;">å‰Šé™¤</button>
                            </div>
                        </div>
                        <div style="margin-top: 10px;">
                            <h4>é…ç½®ã‚³ãƒ¼ãƒ‰</h4>
                            <textarea id="positionCode" style="width: 100%; height: 60px; font-family: monospace; font-size: 12px;" placeholder="é…ç½®ã‚³ãƒ¼ãƒ‰ã‚’ã“ã“ã«è²¼ã‚Šä»˜ã‘ã¦èª­ã¿è¾¼ã‚€ã“ã¨ã‚‚ã§ãã¾ã™"></textarea>
                            <div style="display: flex; gap: 10px; margin-top: 5px;">
                                <button onclick="exportPosition()" style="flex: 1; padding: 8px;">ç¾åœ¨ã®é…ç½®ã‚’ã‚³ãƒ”ãƒ¼</button>
                                <button onclick="importPosition()" style="flex: 1; padding: 8px;">ã‚³ãƒ¼ãƒ‰ã‹ã‚‰èª­è¾¼</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h2>ğŸ“Š çŠ¶æ…‹</h2>
                    <div id="status" class="status">é§’ã‚’é…ç½®ã—ã¦ãã ã•ã„ï¼ˆåº§æ¨™ä¾‹ï¼šï¼•ä¸€ç‰ï¼‰</div>
                    <div id="stats" class="stats"></div>
                    <div id="moveList" class="move-list" style="display: none;"></div>
                    <div style="margin-top: 10px;">
                        <label>
                            <input type="checkbox" id="debugMode" onchange="toggleDebugMode()">
                            ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰
                        </label>
                    </div>
                    <div id="debugOutput" style="display: none; margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 5px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // åº§æ¨™å¤‰æ›ï¼ˆäººé–“è¡¨è¨˜ã‚’åŸºæº–ã«ï¼‰
        const SUJI_MAP = {'ï¼™': 0, 'ï¼˜': 1, 'ï¼—': 2, 'ï¼–': 3, 'ï¼•': 4, 'ï¼”': 5, 'ï¼“': 6, 'ï¼’': 7, 'ï¼‘': 8};
        const DAN_MAP = {'ä¸€': 0, 'äºŒ': 1, 'ä¸‰': 2, 'å››': 3, 'äº”': 4, 'å…­': 5, 'ä¸ƒ': 6, 'å…«': 7, 'ä¹': 8};
        const SUJI_STR = ['ï¼™', 'ï¼˜', 'ï¼—', 'ï¼–', 'ï¼•', 'ï¼”', 'ï¼“', 'ï¼’', 'ï¼‘'];
        const DAN_STR = ['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹'];

        // äººé–“è¡¨è¨˜ã‹ã‚‰å†…éƒ¨åº§æ¨™ã¸
        function humanToInternal(humanPos) {
            if (!humanPos || humanPos.length !== 2) return null;
            const suji = SUJI_MAP[humanPos[0]];
            const dan = DAN_MAP[humanPos[1]];
            if (suji === undefined || dan === undefined) return null;
            return [dan, suji];
        }

        // å†…éƒ¨åº§æ¨™ã‹ã‚‰äººé–“è¡¨è¨˜ã¸
        function internalToHuman(row, col) {
            return SUJI_STR[col] + DAN_STR[row];
        }

        // è©°å°†æ£‹ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆãªã®ã¯è©°ã‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰
        class TsumeShogi {
            constructor() {
                this.board = Array(9).fill(null).map(() => Array(9).fill(null));
                this.currentSide = 'sente';
                this.selectedPiece = null;
                this.solving = false;
                this.mochiGoma = { sente: {}, gote: {} };
                this.hashTable = new Map();
                this.nodeCount = 0;
                this.maxDepth = 25;  // æ·±ã•åˆ¶é™ã‚’å¢—ã‚„ã—ã¦æ·±ã„è©°ã¿ã‚‚è§£ã‘ã‚‹ã‚ˆã†ã«
                this.debugMode = false;  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰è¿½åŠ 
                this.killerMoves = new Map();  // ã‚­ãƒ©ãƒ¼ãƒ ãƒ¼ãƒ–ï¼ˆè‰¯ã„æ‰‹ã‚’è¨˜æ†¶ï¼‰
                this.historyTable = new Map();  // ãƒ’ã‚¹ãƒˆãƒªãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆæ‰‹ã®è©•ä¾¡å€¤ï¼‰
                this.init();
            }

            init() {
                this.createBoard();
                this.setupEventListeners();
                this.updateStatus('é§’ã‚’é…ç½®ã—ã¦ãã ã•ã„');
            }

            createBoard() {
                const boardElement = document.getElementById('board');
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.onclick = () => this.cellClick(row, col);
                        
                        const pos = internalToHuman(row, col);
                        cell.title = pos;
                        
                        boardElement.appendChild(cell);
                    }
                }
            }

            setupEventListeners() {
                document.querySelectorAll('.piece-btn').forEach(btn => {
                    btn.onclick = () => {
                        document.querySelectorAll('.piece-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        this.selectedPiece = btn.dataset.piece;
                    };
                });

                document.querySelectorAll('.side-btn').forEach(btn => {
                    btn.onclick = () => {
                        document.querySelectorAll('.side-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        this.currentSide = btn.dataset.side;
                    };
                });
            }

            cellClick(row, col) {
                if (this.solving) return;
                
                if (this.selectedPiece === 'å‰Šé™¤') {
                    this.board[row][col] = null;
                    this.updateBoard();
                    return;
                }
                
                if (this.selectedPiece) {
                    this.board[row][col] = {
                        piece: this.selectedPiece,
                        side: this.currentSide
                    };
                    this.updateBoard();
                }
            }

            updateBoard() {
                const cells = document.querySelectorAll('.cell');
                cells.forEach((cell, index) => {
                    const row = Math.floor(index / 9);
                    const col = index % 9;
                    const piece = this.board[row][col];
                    
                    if (piece) {
                        cell.innerHTML = `<span class="piece ${piece.side}">${piece.piece}</span>`;
                    } else {
                        cell.innerHTML = '';
                    }
                });
            }

            // ç›¤é¢ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–
            hashPosition() {
                let hash = '';
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            hash += `${internalToHuman(row, col)}${piece.piece}${piece.side[0]}`;
                        }
                    }
                }
                for (const [piece, count] of Object.entries(this.mochiGoma.sente)) {
                    hash += `S${piece}${count}`;
                }
                return hash;
            }

            // ãªã®ã¯è©°ã‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ãƒ¡ã‚¤ãƒ³
            solveTsume() {
                if (this.debugMode) {
                    this.debugLog('=== è©°å°†æ£‹è§£æé–‹å§‹ ===');
                    this.debugLog('ç¾åœ¨ã®ç›¤é¢:');
                    this.debugBoard();
                }
                // æ—¢ã«æ¢ç´¢ä¸­ã®å ´åˆã¯å®Ÿè¡Œã—ãªã„
                if (this.solving) {
                    this.updateStatus('æ—¢ã«æ¢ç´¢ä¸­ã§ã™', 'error');
                    return;
                }
                
                this.solving = true;
                this.nodeCount = 0;
                this.hashTable.clear();
                this.killerMoves.clear();  // ã‚­ãƒ©ãƒ¼ãƒ ãƒ¼ãƒ–ã‚’ã‚¯ãƒªã‚¢
                this.historyTable.clear();  // ãƒ’ã‚¹ãƒˆãƒªãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ã‚¯ãƒªã‚¢
                this.searchStartTime = Date.now();  // æ¢ç´¢é–‹å§‹æ™‚åˆ»
                this.maxSearchTime = 10000;  // æœ€å¤§æ¢ç´¢æ™‚é–“ï¼ˆ10ç§’ï¼šåˆé§’ã‚’å«ã‚€3æ‰‹è©°ã‚å¯¾å¿œï¼‰
                this.maxNodes = 20000;  // æœ€å¤§ãƒãƒ¼ãƒ‰æ•°ï¼ˆ20000ï¼šåˆé§’æ¢ç´¢ã«å¿…è¦ï¼‰
                this.repetitionTable = new Map();  // åƒæ—¥æ‰‹æ¤œå‡ºç”¨
                this.updateStatus('æ¢ç´¢ä¸­...', 'processing');
                
                // ç›¤é¢å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
                const validationResult = this.validateBoard();
                if (!validationResult.valid) {
                    this.updateStatus(validationResult.message, 'error');
                    this.solving = false;
                    return;
                }
                
                // å¾Œæ‰‹ç‰ã®ä½ç½®ç¢ºèª
                let goteKingPos = null;
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.piece === 'ç‰' && piece.side === 'gote') {
                            goteKingPos = internalToHuman(row, col);
                            break;
                        }
                    }
                }
                
                if (!goteKingPos) {
                    this.updateStatus('å¾Œæ‰‹ã®ç‰ã‚’é…ç½®ã—ã¦ãã ã•ã„', 'error');
                    this.solving = false;
                    return;
                }

                // éåŒæœŸã§å®Ÿè¡Œ
                setTimeout(() => {
                    try {
                        const startTime = Date.now();
                        let solution = null;
                        
                        // åå¾©æ·±åŒ–
                        for (let depth = 1; depth <= this.maxDepth; depth++) {
                            if (this.debugMode) {
                                this.debugLog(`\n=== æ·±ã• ${depth} ã®æ¢ç´¢é–‹å§‹ ===`);
                                this.debugLog(`ç¾åœ¨ã®ãƒãƒ¼ãƒ‰æ•°: ${this.nodeCount}`);
                            }
                            
                            const result = this.search(depth, true);
                            if (result) {
                                solution = result;
                                break;
                            }
                            
                            // åˆ¶é™ãƒã‚§ãƒƒã‚¯
                            const elapsed = Date.now() - this.searchStartTime;
                            if (this.nodeCount > this.maxNodes || elapsed > this.maxSearchTime) {
                                if (this.debugMode) {
                                    this.debugLog(`æ¢ç´¢åˆ¶é™ã«åˆ°é”: ãƒãƒ¼ãƒ‰æ•°=${this.nodeCount}, æ™‚é–“=${elapsed}ms`);
                                }
                                break;
                            }
                        }
                        
                        const elapsed = Date.now() - startTime;
                        
                        if (solution) {
                            this.updateStatus(`è©°ã¿ã¾ã—ãŸï¼ ${solution.length}æ‰‹è©°ã‚`, 'success');
                            this.displayMoves(solution);
                        } else {
                            this.updateStatus('è©°ã¿ã¾ã›ã‚“', 'error');
                        }
                        
                        document.getElementById('stats').innerHTML = 
                            `æ¢ç´¢ãƒãƒ¼ãƒ‰æ•°: ${this.nodeCount.toLocaleString()} | ` +
                            `æ™‚é–“: ${(elapsed / 1000).toFixed(2)}ç§’`;
                        
                    } catch (error) {
                        console.error('ã‚¨ãƒ©ãƒ¼:', error);
                        this.updateStatus('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
                    } finally {
                        this.solving = false;
                    }
                }, 10);
            }

            // ã™ã¹ã¦ã®è©°ã¿å¤‰åŒ–ã‚’åé›†
            collectAllMateVariations(depth) {
                const variations = [];
                
                // ãƒãƒƒã‚·ãƒ¥ãƒ†ãƒ¼ãƒ–ãƒ«ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆã¯åˆæœŸåŒ–
                if (!this.hashTable) {
                    this.hashTable = new Map();
                }
                
                // åˆæ‰‹ã®ç‹æ‰‹ã‚’ã™ã¹ã¦ç”Ÿæˆ
                const checks = this.generateChecks();
                
                for (const firstMove of checks) {
                    const backup1 = this.makeMove(firstMove);
                    
                    // ã“ã®æ‰‹ã§è©°ã‚€ã‹ç¢ºèª
                    const result = this.search(depth - 1, false);
                    
                    if (result !== null && result !== undefined) {
                        // è©°ã¿ãŒã‚ã‚‹å ´åˆã€ã™ã¹ã¦ã®å¤‰åŒ–ã‚’åé›†
                        const moveVariations = this.collectVariationsAfterMove(firstMove, depth - 1);
                        if (moveVariations.length > 0) {
                            variations.push({
                                firstMove: this.formatMove(firstMove),
                                variations: moveVariations
                            });
                        }
                    }
                    
                    this.unmakeMove(firstMove, backup1);
                }
                
                return variations;
            }
            
            // ç‰¹å®šã®æ‰‹ã®ã‚ã¨ã®ã™ã¹ã¦ã®å¤‰åŒ–ã‚’åé›†
            collectVariationsAfterMove(firstMove, remainingDepth) {
                const variations = [];
                
                if (!this.isCheck('gote')) {
                    return variations;
                }
                
                const evasions = this.generateEvasions();
                
                if (evasions.length === 0) {
                    // å³è©°ã¿
                    return [{
                        moves: [],
                        result: 'è©°ã¿'
                    }];
                }
                
                // å„å¿œæ‰‹ã«å¯¾ã—ã¦è©°ã¿ã‚’ç¢ºèª
                for (const evasion of evasions) {
                    const backup = this.makeMove(evasion);
                    
                    if (!this.isCheck('gote')) {
                        // ç‹æ‰‹ãŒè§£é™¤ã•ã‚ŒãŸå ´åˆã€å…ˆæ‰‹ã®è©°ã¿æ‰‹ã‚’æ¢ã™
                        const checks = this.generateChecks();
                        
                        for (const check of checks) {
                            const backup2 = this.makeMove(check);
                            const finalEvasions = this.generateEvasions();
                            
                            if (finalEvasions.length === 0) {
                                // è©°ã¿ç™ºè¦‹
                                variations.push({
                                    moves: [this.formatMove(evasion), this.formatMove(check)],
                                    result: 'è©°ã¿'
                                });
                            }
                            
                            this.unmakeMove(check, backup2);
                        }
                    }
                    
                    this.unmakeMove(evasion, backup);
                }
                
                return variations;
            }
            
            // æ¢ç´¢æœ¬ä½“ï¼ˆå˜ä¸€ã®æ‰‹é †ã®ã¿ï¼‰
            search(depth, isSente) {
                // æ·±ã•0ã®å ´åˆ
                if (depth === 0) {
                    // å¾Œæ‰‹ãŒç‹æ‰‹ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆæ‰‹ç•ªã«é–¢ä¿‚ãªãï¼‰
                    if (this.isCheck('gote')) {
                        const evasions = this.generateEvasions();
                        if (evasions.length === 0) {
                            return []; // è©°ã¿
                        }
                    }
                    return null;
                }
                
                // ãƒãƒ¼ãƒ‰æ•°åˆ¶é™ãƒã‚§ãƒƒã‚¯
                this.nodeCount++;
                if (this.nodeCount > this.maxNodes) {
                    if (this.debugMode) {
                        this.debugLog(`ãƒãƒ¼ãƒ‰æ•°åˆ¶é™(${this.maxNodes})ã«åˆ°é”`);
                    }
                    return null;
                }
                
                // æ™‚é–“åˆ¶é™ãƒã‚§ãƒƒã‚¯
                if (this.nodeCount % 1000 === 0) {
                    const elapsed = Date.now() - this.searchStartTime;
                    if (elapsed > this.maxSearchTime) {
                        if (this.debugMode) {
                            this.debugLog(`æ™‚é–“åˆ¶é™(${this.maxSearchTime}ms)ã«åˆ°é”`);
                        }
                        return null;
                    }
                }
                
                // åƒæ—¥æ‰‹ãƒã‚§ãƒƒã‚¯ï¼ˆæ·±ã•ã‚‚è€ƒæ…®ï¼‰
                const positionKey = this.hashPosition() + '_d' + depth;
                const repetitions = this.repetitionTable.get(positionKey) || 0;
                if (repetitions >= 2) {  // 2å›ç›®ã§åƒæ—¥æ‰‹åˆ¤å®šï¼ˆ3å›ç›®ã‚’å¾…ãŸãªã„ï¼‰
                    if (this.debugMode && repetitions === 2) {
                        this.debugLog('åƒæ—¥æ‰‹ã‚’æ¤œå‡ºï¼ˆåŒä¸€å±€é¢2å›ç›®ï¼‰');
                    }
                    return null;
                }
                this.repetitionTable.set(positionKey, repetitions + 1);
                
                // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
                if (this.debugMode && this.nodeCount % 1000 === 0) {
                    this.debugLog(`[é€²æ—] ãƒãƒ¼ãƒ‰æ•°: ${this.nodeCount}, æ·±ã•: ${depth}, æ‰‹ç•ª: ${isSente ? 'å…ˆæ‰‹' : 'å¾Œæ‰‹'}`);
                }
                
                // ãƒãƒƒã‚·ãƒ¥è¡¨ç¢ºèªï¼ˆæ”¹å–„ç‰ˆï¼‰
                const hash = this.hashPosition() + '_' + isSente;
                const cached = this.hashTable.get(hash);
                if (cached && cached.depth >= depth) {
                    // åƒæ—¥æ‰‹ã‚«ã‚¦ãƒ³ãƒˆã‚’æˆ»ã™
                    this.repetitionTable.set(positionKey, Math.max(0, repetitions - 1));
                    return cached.result;
                }
                
                // ç¾åœ¨ã®çŠ¶æ…‹ç¢ºèª
                const isCheck = this.isCheck(isSente ? 'gote' : 'sente');
                
                if (isSente) {
                    // å…ˆæ‰‹ç•ªï¼šç‹æ‰‹ã‚’ã‹ã‘ã‚‹
                    let moves = this.generateChecks();
                    
                    if (this.debugMode && depth <= 3) {
                        this.debugLog(`[å…ˆæ‰‹] ç‹æ‰‹å¯èƒ½æ‰‹æ•°: ${moves.length}`);
                        if (moves.length > 0 && moves.length <= 10) {
                            this.debugLog(`  æ‰‹: ${moves.slice(0, 10).map(m => this.formatMove(m)).join(', ')}`);
                        }
                    }
                    
                    // æ‰‹ã®ä¸¦ã³æ›¿ãˆï¼ˆè‰¯ã„æ‰‹ã‚’å…ˆã«è©¦ã™ï¼‰
                    moves = this.orderMoves(moves, depth);
                    
                    for (const move of moves) {
                        const backup = this.makeMove(move);
                        const result = this.search(depth - 1, false);
                        this.unmakeMove(move, backup);
                        
                        if (result !== null) {
                            const solution = [this.formatMove(move), ...result];
                            this.hashTable.set(hash, { depth, result: solution });
                            
                            // ã‚­ãƒ©ãƒ¼ãƒ ãƒ¼ãƒ–ã¨ã—ã¦è¨˜éŒ²
                            this.recordKillerMove(depth, move);
                            
                            // åƒæ—¥æ‰‹ã‚«ã‚¦ãƒ³ãƒˆã‚’æˆ»ã™
                            this.repetitionTable.set(positionKey, Math.max(0, repetitions - 1));
                            return solution;
                        }
                    }
                    
                    this.hashTable.set(hash, { depth, result: null });
                    // åƒæ—¥æ‰‹ã‚«ã‚¦ãƒ³ãƒˆã‚’æˆ»ã™
                    this.repetitionTable.set(positionKey, Math.max(0, repetitions - 1));
                    return null;
                    
                } else {
                    // å¾Œæ‰‹ç•ªï¼šç‹æ‰‹å›é¿
                    if (!this.isCheck('gote')) {
                        // å¾Œæ‰‹ãŒç‹æ‰‹ã•ã‚Œã¦ã„ãªã„å ´åˆã¯è©°ã¿ã§ã¯ãªã„
                        if (this.debugMode && depth <= 3) {
                            this.debugLog(`[å¾Œæ‰‹] ç‹æ‰‹ã•ã‚Œã¦ã„ãªã„ã®ã§è©°ã¿ã§ã¯ãªã„`);
                        }
                        // åƒæ—¥æ‰‹ã‚«ã‚¦ãƒ³ãƒˆã‚’æˆ»ã™
                        this.repetitionTable.set(positionKey, Math.max(0, repetitions - 1));
                        return null;
                    }
                    
                    const moves = this.generateEvasions();
                    
                    if (this.debugMode && depth <= 5) {
                        this.debugLog(`[å¾Œæ‰‹] ç‹æ‰‹å›é¿æ‰‹æ•°: ${moves.length}`);
                        if (moves.length === 0) {
                            this.debugLog(`  è©°ã¿ï¼`);
                        } else if (moves.length <= 5) {
                            this.debugLog(`  æ‰‹: ${moves.map(m => this.formatMove(m)).join(', ')}`);
                        }
                    }
                    
                    if (moves.length === 0) {
                        // åƒæ—¥æ‰‹ã‚«ã‚¦ãƒ³ãƒˆã‚’æˆ»ã™
                        this.repetitionTable.set(positionKey, Math.max(0, repetitions - 1));
                        return [];  // è©°ã¿
                    }
                    
                    // ã™ã¹ã¦ã®å›é¿æ‰‹ã‚’è©¦ã™
                    let bestResult = null;
                    for (const move of moves) {
                        const backup = this.makeMove(move);
                        
                        // ç‹æ‰‹ãŒè§£é™¤ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
                        if (!this.isCheck('gote')) {
                            const result = this.search(depth - 1, true);
                            this.unmakeMove(move, backup);
                            
                            if (result === null) {
                                this.hashTable.set(hash, { depth, result: null });
                                // åƒæ—¥æ‰‹ã‚«ã‚¦ãƒ³ãƒˆã‚’æˆ»ã™
                                this.repetitionTable.set(positionKey, Math.max(0, repetitions - 1));
                                return null;  // ã“ã®æ‰‹ã§é€ƒã’ã‚‰ã‚Œã‚‹
                            } else if (result !== null) {
                                // ã“ã®å¿œæ‰‹ã«å¯¾ã—ã¦è©°ã¿ãŒã‚ã‚‹ã®ã§è¨˜éŒ²
                                bestResult = [this.formatMove(move), ...result];
                            }
                        } else {
                            this.unmakeMove(move, backup);
                        }
                    }
                    
                    // ã™ã¹ã¦ã®æ‰‹ã§è©°ã‚€å ´åˆã¯æœ€çŸ­ã®æ‰‹é †ã‚’è¿”ã™
                    if (bestResult !== null) {
                        this.hashTable.set(hash, { depth, result: bestResult });
                        // åƒæ—¥æ‰‹ã‚«ã‚¦ãƒ³ãƒˆã‚’æˆ»ã™
                        this.repetitionTable.set(positionKey, Math.max(0, repetitions - 1));
                        return bestResult;
                    }
                    
                    // ã™ã¹ã¦ã®æ‰‹ã§è©°ã‚€ï¼ˆç‹æ‰‹ãŒè§£é™¤ã§ããªã„å ´åˆï¼‰
                    this.hashTable.set(hash, { depth, result: [] });
                    // åƒæ—¥æ‰‹ã‚«ã‚¦ãƒ³ãƒˆã‚’æˆ»ã™
                    this.repetitionTable.set(positionKey, Math.max(0, repetitions - 1));
                    return [];
                }
            }

            // ç‹æ‰‹ç”Ÿæˆï¼ˆé–‹ãç‹æ‰‹ã‚‚å«ã‚€ï¼‰
            generateChecks() {
                const checks = [];
                
                // ç›¤ä¸Šã®é§’ã®ç§»å‹•
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.side === 'sente') {
                            const moves = this.getPieceMoves(row, col, piece);
                            
                            // ãƒ‡ãƒãƒƒã‚°ï¼šï¼’äºŒé£›ã®æ‰‹ã‚’ç¢ºèª
                            if (this.debugMode && row === 1 && col === 7 && piece.piece === 'é£›') {
                                this.debugLog(`ï¼’äºŒé£›ã®ç”Ÿæˆã•ã‚ŒãŸæ‰‹æ•°: ${moves.length}`);
                                for (const m of moves) {
                                    if (m.to === 'ï¼’ä¸€') {
                                        this.debugLog(`  ï¼’ä¸€ã¸ã®æ‰‹: piece=${m.piece}, promote=${m.promote}`);
                                    }
                                }
                            }
                            
                            for (const move of moves) {
                                // moveã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã€å…ƒã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒ
                                const moveCopy = {...move};
                                const backup = this.makeMove(move);
                                // ç§»å‹•å¾Œã«ç‹æ‰‹ã«ãªã£ã¦ã„ã‚‹ã‹ï¼ˆç›´æ¥ç‹æ‰‹ã¾ãŸã¯é–‹ãç‹æ‰‹ï¼‰
                                if (this.isCheck('gote')) {
                                    // ã‚³ãƒ”ãƒ¼ã—ãŸæ–¹ã‚’ä½¿ç”¨
                                    checks.push(moveCopy);
                                    if (this.debugMode) {
                                        this.debugLog(`ç‹æ‰‹ç™ºè¦‹: ${this.formatMove(moveCopy)}`);
                                    }
                                }
                                this.unmakeMove(move, backup);
                            }
                        }
                    }
                }
                
                // æŒã¡é§’ã‚’æ‰“ã¤
                for (const [piece, count] of Object.entries(this.mochiGoma.sente)) {
                    if (count > 0) {
                        for (let row = 0; row < 9; row++) {
                            for (let col = 0; col < 9; col++) {
                                if (!this.board[row][col] && this.canDrop(piece, row, col)) {
                                    const move = {
                                        type: 'drop',
                                        piece: piece,
                                        to: internalToHuman(row, col)
                                    };
                                    
                                    const backup = this.makeMove(move);
                                    if (this.isCheck('gote')) {
                                        checks.push(move);
                                    }
                                    this.unmakeMove(move, backup);
                                }
                            }
                        }
                    }
                }
                
                return checks;
            }

            // ç‹æ‰‹å›é¿æ‰‹ç”Ÿæˆ
            generateEvasions() {
                const evasions = [];
                
                // ç‰ã‚’æ¢ã™
                let kingPos = null;
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.piece === 'ç‰' && piece.side === 'gote') {
                            kingPos = [row, col];
                            break;
                        }
                    }
                }
                
                if (!kingPos) return evasions;
                
                if (this.debugMode) {
                    this.debugLog(`  å¾Œæ‰‹ç‰ã®ä½ç½®: ${internalToHuman(kingPos[0], kingPos[1])}`);
                    // æ”»æ’ƒé§’ã®ç¢ºèª
                    const attackers = this.getAttackers(kingPos[0], kingPos[1], 'sente');
                    if (attackers.length > 0) {
                        for (const att of attackers) {
                            const p = this.board[att[0]][att[1]];
                            this.debugLog(`  ç‹æ‰‹ã—ã¦ã„ã‚‹é§’: ${p.piece} at ${internalToHuman(att[0], att[1])}`);
                        }
                    }
                }
                
                // 1. ç‰ã®ç§»å‹•
                const kingMoves = this.getKingMoves(kingPos[0], kingPos[1]);
                for (const move of kingMoves) {
                    const backup = this.makeMove(move);
                    // ç§»å‹•å¾Œã‚‚ç‹æ‰‹ã•ã‚Œã¦ã„ãªã„ã‹ç¢ºèª
                    if (!this.isCheck('gote')) {
                        evasions.push(move);
                    }
                    this.unmakeMove(move, backup);
                }
                
                // 2. ç‹æ‰‹ã—ã¦ã„ã‚‹é§’ã‚’å–ã‚‹
                const attackers = this.getAttackers(kingPos[0], kingPos[1], 'sente');
                if (this.debugMode) {
                    this.debugLog(`  æ”»æ’ƒè€…æ•°: ${attackers.length}`);
                    if (attackers.length > 0) {
                        for (const att of attackers) {
                            const p = this.board[att[0]][att[1]];
                            this.debugLog(`    æ”»æ’ƒè€…: ${p.piece} at ${internalToHuman(att[0], att[1])}`);
                        }
                    }
                }
                if (attackers.length === 1) {  // ä¸¡ç‹æ‰‹ã§ãªã„å ´åˆã®ã¿
                    const attacker = attackers[0];
                    // å¾Œæ‰‹ã®é§’ã§å–ã‚Œã‚‹ã‹ç¢ºèª
                    for (let row = 0; row < 9; row++) {
                        for (let col = 0; col < 9; col++) {
                            const piece = this.board[row][col];
                            if (piece && piece.side === 'gote' && piece.piece !== 'ç‰') {
                                if (this.canAttack(row, col, attacker[0], attacker[1], piece)) {
                                    const move = {
                                        type: 'move',
                                        from: internalToHuman(row, col),
                                        to: internalToHuman(attacker[0], attacker[1]),
                                        piece: piece.piece,
                                        captured: this.board[attacker[0]][attacker[1]]
                                    };
                                    evasions.push(move);
                                }
                            }
                        }
                    }
                }
                
                // 3. åˆé§’ï¼ˆé£›ã³é§’ã«ã‚ˆã‚‹ç‹æ‰‹ã®å ´åˆï¼‰
                if (attackers.length === 1) {
                    const attacker = attackers[0];
                    const attackPiece = this.board[attacker[0]][attacker[1]];
                    
                    if (this.debugMode) {
                        this.debugLog(`  åˆé§’ãƒã‚§ãƒƒã‚¯é–‹å§‹: æ”»æ’ƒé§’=${attackPiece.piece} at ${internalToHuman(attacker[0], attacker[1])}`);
                    }
                    
                    // é£›ã³é§’ã«ã‚ˆã‚‹ç‹æ‰‹ã‹ç¢ºèª
                    if (['é£›', 'é¾', 'è§’', 'é¦¬', 'é¦™'].includes(attackPiece.piece)) {
                        if (this.debugMode) {
                            this.debugLog(`  â†’ é£›ã³é§’ã«ã‚ˆã‚‹ç‹æ‰‹ãªã®ã§åˆé§’ã‚’æ¤œè¨`);
                        }
                        // ç‹æ‰‹ã®ç·šä¸Šã®ãƒã‚¹ã‚’æ¢ã™
                        const dr = Math.sign(kingPos[0] - attacker[0]);
                        const dc = Math.sign(kingPos[1] - attacker[1]);
                        
                        let r = attacker[0] + dr;
                        let c = attacker[1] + dc;
                        
                        while (r !== kingPos[0] || c !== kingPos[1]) {
                            // ã“ã®ãƒã‚¹ã«åˆé§’ã§ãã‚‹ã‹
                            const blockPos = internalToHuman(r, c);
                            
                            if (this.debugMode) {
                                this.debugLog(`    åˆé§’å€™è£œä½ç½®: ${blockPos} [${r},${c}]`);
                            }
                            
                            // å¾Œæ‰‹ã®é§’ã‚’ç§»å‹•ã—ã¦åˆé§’ï¼ˆåŠ¹ç‡åŒ–ã®ãŸã‚æ—©æœŸçµ‚äº†ã‚’è¿½åŠ ï¼‰
                            let foundMoveBlock = false;
                            for (let row = 0; row < 9 && !foundMoveBlock; row++) {
                                for (let col = 0; col < 9 && !foundMoveBlock; col++) {
                                    const piece = this.board[row][col];
                                    if (piece && piece.side === 'gote' && piece.piece !== 'ç‰') {
                                        const moves = this.getPieceMoves(row, col, piece);
                                        for (const move of moves) {
                                            if (move.to === blockPos) {
                                                evasions.push(move);
                                                // è¤‡æ•°ã®åˆé§’å€™è£œã‚’å…¨ã¦åé›†ï¼ˆæœ€å–„æ‰‹ã‚’é¸ã¶ãŸã‚ï¼‰
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // å¾Œæ‰‹ã®æŒé§’ã‹ã‚‰åˆé§’ã‚’æ‰“ã¤
                            // è©°å°†æ£‹ã§ã¯å…ˆæ‰‹ã®æŒé§’ä»¥å¤–ã¯å…¨ã¦å¾Œæ‰‹ãŒæŒã£ã¦ã„ã‚‹ãŸã‚ã€
                            // ç›¤ä¸Šã«ãªã„é§’ç¨®ã‚’å¾Œæ‰‹ã®æŒé§’ã¨ã—ã¦æ‰±ã†
                            const [blockRow, blockCol] = humanToInternal(blockPos);
                            
                            // ç©ºããƒã‚¹ã‹ç¢ºèª
                            if (this.board[blockRow][blockCol]) {
                                if (this.debugMode) {
                                    this.debugLog(`    â†’ ${blockPos}ã¯åŸ‹ã¾ã£ã¦ã„ã‚‹ã®ã§ã‚¹ã‚­ãƒƒãƒ—`);
                                }
                                r += dr;
                                c += dc;
                                continue;
                            }
                            
                            if (this.debugMode) {
                                this.debugLog(`    â†’ ${blockPos}ã¯ç©ºããƒã‚¹ã€åˆé§’ã‚’æ¤œè¨`);
                            }
                            
                            // ã¾ãšã€ã“ã®åœ°ç‚¹ã¸ã®æ”»æ’ƒè€…æ•°ã‚’ç¢ºèªï¼ˆä¸¡åŠ¹ãåˆ¤å®šï¼‰
                            const blockAttackers = this.getAttackers(blockRow, blockCol, 'sente');
                            
                            // ä¸¡åŠ¹ãï¼ˆ2ã¤ä»¥ä¸Šã®é§’ã§æ”»æ’ƒï¼‰ã®å ´åˆã€åˆé§’ã¯ç„¡åŠ¹
                            if (blockAttackers.length <= 1) {
                                // åˆé§’ã®å„ªå…ˆé †ä½ï¼ˆä¾¡å€¤ã®ä½ã„é§’ã‹ã‚‰è©¦ã™ï¼‰
                                // è©°å°†æ£‹ã§ã¯é€šå¸¸ã€æœ€ã‚‚å®‰ã„é§’ã§åˆé§’ã™ã‚‹ã®ãŒæœ€å–„
                                const pieceOrder = ['æ­©', 'é¦™', 'æ¡‚', 'éŠ€', 'é‡‘', 'è§’', 'é£›'];
                                
                                if (this.debugMode) {
                                    this.debugLog(`    åˆé§’ã‚’æ‰“ã¤å€™è£œä½ç½®: ${blockPos} (ä¸¡åŠ¹ãæ•°: ${blockAttackers.length})`);
                                    // å¾Œæ‰‹ã®ä½¿ãˆã‚‹é§’ã‚’ç¢ºèª
                                    const usablePieces = [];
                                    for (const p of ['æ­©', 'é¦™', 'æ¡‚', 'éŠ€', 'é‡‘', 'è§’', 'é£›']) {
                                        if (this.canGoteUsePiece(p)) {
                                            usablePieces.push(p);
                                        }
                                    }
                                    this.debugLog(`    å¾Œæ‰‹ãŒä½¿ãˆã‚‹é§’: ${usablePieces.join(', ')}`);
                                }
                                
                                // å„é§’ç¨®ã«ã¤ã„ã¦åˆé§’ã‚’è©¦ã™
                                for (const piece of pieceOrder) {
                                    // ã“ã®é§’ç¨®ãŒå¾Œæ‰‹ã®æŒé§’ã¨ã—ã¦ä½¿ãˆã‚‹ã‹ç¢ºèª
                                    if (this.canGoteUsePiece(piece)) {
                                        // æ‰“ã¦ã‚‹å ´æ‰€ã‹ç¢ºèªï¼ˆäºŒæ­©ã€è¡Œãæ‰€ã®ãªã„é§’ãƒã‚§ãƒƒã‚¯ï¼‰
                                        if (this.canDropGote(piece, blockRow, blockCol)) {
                                            // ã“ã®åˆé§’ãŒæœ‰åŠ¹ã‹ã©ã†ã‹åˆ¤å®š
                                            const testMove = {
                                                type: 'drop',
                                                piece: piece,
                                                to: blockPos,
                                                side: 'gote'
                                            };
                                            
                                            if (this.debugMode) {
                                                this.debugLog(`      ${piece}ã‚’${blockPos}ã«æ‰“ã¤ã“ã¨ã‚’æ¤œè¨`);
                                            }
                                            
                                            // åˆé§’ã‚’å®Ÿè¡Œã—ã¦ã¿ã‚‹
                                            const backup = this.makeMove(testMove);
                                            const stillInCheck = this.isCheck('gote');
                                            this.unmakeMove(testMove, backup);
                                            
                                            // ç‹æ‰‹ãŒè§£é™¤ã•ã‚Œã‚Œã°æœ‰åŠ¹ãªåˆé§’
                                            if (!stillInCheck) {
                                                if (this.debugMode) {
                                                    this.debugLog(`      â†’ æœ‰åŠ¹ãªåˆé§’: â–³${blockPos}${piece}æ‰“`);
                                                }
                                                evasions.push(testMove);
                                                // è¤‡æ•°ã®åˆé§’ã‚’å…¨ã¦è€ƒæ…®ï¼ˆæœ€å–„æ‰‹ã‚’æ¢ã™ãŸã‚ï¼‰
                                            }
                                        }
                                    }
                                }
                            }
                            
                            r += dr;
                            c += dc;
                        }
                    }
                }
                
                return evasions;
            }

            // ç‰¹å®šã®ãƒã‚¹ã‚’æ”»æ’ƒã—ã¦ã„ã‚‹é§’ã‚’å–å¾—
            getAttackers(targetRow, targetCol, attackerSide) {
                const attackers = [];
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.side === attackerSide) {
                            if (this.canAttack(row, col, targetRow, targetCol, piece)) {
                                attackers.push([row, col]);
                            }
                        }
                    }
                }
                
                return attackers;
            }

            // é§’ã®å‹•ãç”Ÿæˆ
            getPieceMoves(row, col, piece) {
                const moves = [];
                const from = internalToHuman(row, col);
                const directions = this.getPieceDirections(piece.piece, piece.side);
                
                for (const dir of directions) {
                    // é£›ã³é§’ã‹ã©ã†ã‹åˆ¤å®š
                    const isRangedPiece = ['é£›', 'é¾', 'è§’', 'é¦¬', 'é¦™'].includes(piece.piece);
                    const maxRange = isRangedPiece ? 8 : 1;
                    
                    for (let dist = 1; dist <= maxRange; dist++) {
                        const newRow = row + dir.row * dist;
                        const newCol = col + dir.col * dist;
                        
                        if (!this.isInBoard(newRow, newCol)) break;
                        
                        const target = this.board[newRow][newCol];
                        if (target && target.side === piece.side) break;
                        
                        const to = internalToHuman(newRow, newCol);
                        // æˆã‚Œã‚‹å ´åˆã¯æˆã‚‰ãšã¨æˆã‚Šã®ä¸¡æ–¹ã‚’ç”Ÿæˆï¼ˆå¼·åˆ¶æˆã‚Šã‚’é™¤ãï¼‰
                        const canProm = this.canPromote(piece.piece, row, newRow, piece.side);
                        const mustProm = this.mustPromote(piece.piece, row, newRow, piece.side);
                        
                        // å¼·åˆ¶æˆã‚Šã§ãªã‘ã‚Œã°ã€æˆã‚‰ãšã®æ‰‹ã‚’ç”Ÿæˆ
                        if (!mustProm) {
                            // æˆã‚‰ãšã®æ‰‹
                            moves.push({
                                type: 'move',
                                from: from,
                                to: to,
                                piece: piece.piece,
                                captured: target,
                                side: piece.side
                            });
                        }
                        
                        // æˆã‚Œã‚‹å ´åˆã¯æˆã‚Šã®æ‰‹ã‚‚ç”Ÿæˆ
                        if (canProm) {
                            // æˆã‚Šã®æ‰‹
                            moves.push({
                                type: 'move',
                                from: from,
                                to: to,
                                piece: piece.piece,
                                captured: target,
                                promote: true,
                                side: piece.side
                            });
                        }
                        
                        // å¼·åˆ¶æˆã‚Šã®å ´åˆã€æˆã‚‰ãšã®æ‰‹ãŒãªã„ã“ã¨ã‚’ç¢ºèª
                        if (mustProm && !canProm) {
                            // ã‚¨ãƒ©ãƒ¼ï¼šå¼·åˆ¶æˆã‚Šãªã®ã«æˆã‚Œãªã„
                            console.error('å¼·åˆ¶æˆã‚Šã‚¨ãƒ©ãƒ¼:', piece.piece, from, to);
                        }
                        
                        // é§’ã‚’å–ã£ãŸã‚‰æ­¢ã¾ã‚‹
                        if (target) break;
                    }
                }
                
                return moves;
            }

            // ç‰ã®å‹•ã
            getKingMoves(row, col) {
                const moves = [];
                const from = internalToHuman(row, col);
                const dirs = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1], [0, 1],
                    [1, -1], [1, 0], [1, 1]
                ];
                
                for (const [dr, dc] of dirs) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (this.isInBoard(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        if (!target || target.side !== 'gote') {
                            moves.push({
                                type: 'move',
                                from: from,
                                to: internalToHuman(newRow, newCol),
                                piece: 'ç‰',
                                captured: target,
                                side: 'gote'
                            });
                        }
                    }
                }
                
                return moves;
            }

            // é§’ã®æ–¹å‘å®šç¾©ï¼ˆç°¡ç•¥ç‰ˆï¼‰
            getPieceDirections(piece, side) {
                const mult = side === 'sente' ? -1 : 1;
                const basicDirs = {
                    'æ­©': [{row: mult, col: 0}],
                    'é¦™': [{row: mult, col: 0}],
                    'æ¡‚': [{row: mult * 2, col: -1}, {row: mult * 2, col: 1}],
                    'éŠ€': [
                        {row: mult, col: -1}, {row: mult, col: 0}, {row: mult, col: 1},
                        {row: -mult, col: -1}, {row: -mult, col: 1}
                    ],
                    'é‡‘': [
                        {row: mult, col: -1}, {row: mult, col: 0}, {row: mult, col: 1},
                        {row: 0, col: -1}, {row: 0, col: 1},
                        {row: -mult, col: 0}
                    ],
                    'è§’': [
                        {row: -1, col: -1}, {row: -1, col: 1},
                        {row: 1, col: -1}, {row: 1, col: 1}
                    ],
                    'é£›': [
                        {row: -1, col: 0}, {row: 1, col: 0},
                        {row: 0, col: -1}, {row: 0, col: 1}
                    ],
                    'ç‰': [
                        {row: -1, col: -1}, {row: -1, col: 0}, {row: -1, col: 1},
                        {row: 0, col: -1}, {row: 0, col: 1},
                        {row: 1, col: -1}, {row: 1, col: 0}, {row: 1, col: 1}
                    ],
                    'é¾': [
                        {row: -1, col: 0}, {row: 1, col: 0},
                        {row: 0, col: -1}, {row: 0, col: 1},
                        {row: -1, col: -1}, {row: -1, col: 1},
                        {row: 1, col: -1}, {row: 1, col: 1}
                    ],
                    'é¦¬': [
                        {row: -1, col: -1}, {row: -1, col: 1},
                        {row: 1, col: -1}, {row: 1, col: 1},
                        {row: -1, col: 0}, {row: 1, col: 0},
                        {row: 0, col: -1}, {row: 0, col: 1}
                    ]
                };
                
                // æˆé§’ã¯é‡‘ã®å‹•ã
                const goldMove = basicDirs['é‡‘'];
                basicDirs['ã¨'] = goldMove;
                basicDirs['æ'] = goldMove;
                basicDirs['åœ­'] = goldMove;
                basicDirs['å…¨'] = goldMove;
                
                return basicDirs[piece] || [];
            }

            // æ‰‹ã‚’å®Ÿè¡Œ
            makeMove(move) {
                const backup = {
                    board: null,
                    mochiGoma: JSON.parse(JSON.stringify(this.mochiGoma))
                };
                
                if (move.type === 'drop') {
                    const [row, col] = humanToInternal(move.to);
                    const side = move.side || 'sente';  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å…ˆæ‰‹
                    this.board[row][col] = { piece: move.piece, side: side };
                    
                    // å…ˆæ‰‹ã®æŒé§’ã‹ã‚‰æ¸›ã‚‰ã™ï¼ˆå¾Œæ‰‹ã®åˆé§’ã¯ä»®æƒ³çš„ã«ç„¡é™ã«ã‚ã‚‹ã®ã§æ¸›ã‚‰ã•ãªã„ï¼‰
                    if (side === 'sente' && this.mochiGoma.sente[move.piece]) {
                        this.mochiGoma.sente[move.piece]--;
                        if (this.mochiGoma.sente[move.piece] === 0) {
                            delete this.mochiGoma.sente[move.piece];
                        }
                    }
                    // å¾Œæ‰‹ã®åˆé§’æ‰“ã¡ã¯æŒé§’ã‚’ç®¡ç†ã—ãªã„ï¼ˆè©°å°†æ£‹ã§ã¯å¾Œæ‰‹ã¯ç›¤ä¸Šã«ãªã„é§’ã‚’å…¨ã¦æŒã£ã¦ã„ã‚‹ï¼‰
                } else {
                    const [fromRow, fromCol] = humanToInternal(move.from);
                    const [toRow, toCol] = humanToInternal(move.to);
                    
                    backup.board = this.board[toRow][toCol];
                    
                    const movingPiece = this.board[fromRow][fromCol];
                    if (move.promote) {
                        this.board[toRow][toCol] = {
                            piece: this.promotePiece(move.piece),
                            side: movingPiece.side
                        };
                    } else {
                        this.board[toRow][toCol] = movingPiece;
                    }
                    this.board[fromRow][fromCol] = null;
                    
                    // é§’ã‚’å–ã£ãŸå ´åˆ
                    if (backup.board) {
                        const demoted = this.demotePiece(backup.board.piece);
                        if (!this.mochiGoma.sente[demoted]) {
                            this.mochiGoma.sente[demoted] = 0;
                        }
                        this.mochiGoma.sente[demoted]++;
                    }
                }
                
                return backup;
            }

            // æ‰‹ã‚’æˆ»ã™
            unmakeMove(move, backup) {
                if (move.type === 'drop') {
                    const [row, col] = humanToInternal(move.to);
                    this.board[row][col] = null;
                } else {
                    const [fromRow, fromCol] = humanToInternal(move.from);
                    const [toRow, toCol] = humanToInternal(move.to);
                    
                    this.board[fromRow][fromCol] = this.board[toRow][toCol];
                    if (move.promote) {
                        this.board[fromRow][fromCol].piece = move.piece;
                    }
                    this.board[toRow][toCol] = backup.board;
                }
                
                this.mochiGoma = backup.mochiGoma;
            }

            // ç‹æ‰‹åˆ¤å®š
            isCheck(side) {
                let kingPos = null;
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.piece === 'ç‰' && piece.side === side) {
                            kingPos = [row, col];
                            break;
                        }
                    }
                }
                
                if (!kingPos) return false;
                
                const enemySide = side === 'sente' ? 'gote' : 'sente';
                
                // å„æ•µé§’ã‹ã‚‰æ”»æ’ƒã•ã‚Œã¦ã„ã‚‹ã‹
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.side === enemySide) {
                            if (this.canAttack(row, col, kingPos[0], kingPos[1], piece)) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }

            // æ”»æ’ƒåˆ¤å®šï¼ˆä¿®æ­£ç‰ˆï¼‰
            canAttack(fromRow, fromCol, toRow, toCol, piece) {
                const dr = toRow - fromRow;
                const dc = toCol - fromCol;
                
                // åŒã˜ä½ç½®ãªã‚‰æ”»æ’ƒã§ããªã„
                if (dr === 0 && dc === 0) return false;
                
                // é§’ç¨®åˆ¥ã®æ”»æ’ƒåˆ¤å®š
                switch (piece.piece) {
                    case 'æ­©':
                        // æ­©ã¯1ãƒã‚¹å‰é€²ã®ã¿
                        const pawnDir = piece.side === 'sente' ? -1 : 1;
                        return dr === pawnDir && dc === 0;
                    
                    case 'é¦™':
                        // é¦™è»Šã¯å‰æ–¹ç›´ç·šï¼ˆå…ˆæ‰‹ã¯ä¸Šã€å¾Œæ‰‹ã¯ä¸‹ï¼‰
                        const lanceDir = piece.side === 'sente' ? -1 : 1;
                        if (dc !== 0 || Math.sign(dr) !== lanceDir) return false;
                        // é€”ä¸­ã«é§’ãŒãªã„ã‹ç¢ºèª
                        return this.checkClearPath(fromRow, fromCol, toRow, toCol);
                    
                    case 'æ¡‚':
                        // æ¡‚é¦¬ã¯2ãƒã‚¹å‰ï¼‹1ãƒã‚¹æ¨ª
                        const knightDir = piece.side === 'sente' ? -2 : 2;
                        return dr === knightDir && Math.abs(dc) === 1;
                    
                    case 'éŠ€':
                        // éŠ€ã¯å‰3æ–¹å‘ã¨å¾Œã‚æ–œã‚
                        const silverForward = piece.side === 'sente' ? -1 : 1;
                        if (Math.abs(dr) === 1 && Math.abs(dc) === 1) return true; // æ–œã‚
                        if (dr === silverForward && dc === 0) return true; // å‰
                        return false;
                    
                    case 'é‡‘':
                    case 'ã¨':
                    case 'æ':
                    case 'åœ­':
                    case 'å…¨':
                        // é‡‘ã¨æˆé§’ã¯é‡‘ã®å‹•ãï¼ˆå‰3æ–¹å‘ã€æ¨ª2æ–¹å‘ã€å¾Œã‚1æ–¹å‘ï¼‰
                        const goldForward = piece.side === 'sente' ? -1 : 1;
                        const goldBackward = -goldForward;
                        if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1) {
                            // å¾Œã‚æ–œã‚ã¯ä¸å¯
                            if (dr === goldBackward && dc !== 0) return false;
                            return true;
                        }
                        return false;
                    
                    case 'é£›':
                        // é£›è»Šã¯ç¸¦æ¨ªç›´ç·š
                        if (dr !== 0 && dc !== 0) return false;
                        return this.checkClearPath(fromRow, fromCol, toRow, toCol);
                    
                    case 'é¾':
                        // é¾ã¯é£›è»Šã®å‹•ãï¼‹æ–œã‚1ãƒã‚¹
                        if (Math.abs(dr) === 1 && Math.abs(dc) === 1) return true; // æ–œã‚1ãƒã‚¹
                        if (dr === 0 || dc === 0) {
                            return this.checkClearPath(fromRow, fromCol, toRow, toCol);
                        }
                        return false;
                    
                    case 'è§’':
                        // è§’ã¯æ–œã‚ç›´ç·š
                        if (Math.abs(dr) !== Math.abs(dc)) return false;
                        return this.checkClearPath(fromRow, fromCol, toRow, toCol);
                    
                    case 'é¦¬':
                        // é¦¬ã¯è§’ã®å‹•ãï¼‹ç¸¦æ¨ª1ãƒã‚¹
                        if (Math.abs(dr) === 1 && dc === 0) return true; // ç¸¦1ãƒã‚¹
                        if (dr === 0 && Math.abs(dc) === 1) return true; // æ¨ª1ãƒã‚¹
                        if (Math.abs(dr) === Math.abs(dc)) {
                            return this.checkClearPath(fromRow, fromCol, toRow, toCol);
                        }
                        return false;
                    
                    case 'ç‰':
                        // ç‰ã¯8æ–¹å‘1ãƒã‚¹
                        return Math.abs(dr) <= 1 && Math.abs(dc) <= 1;
                    
                    default:
                        return false;
                }
            }

            // çµŒè·¯ä¸Šã«é§’ãŒãªã„ã‹ç¢ºèªï¼ˆé£›ã³é§’ç”¨ï¼‰
            checkClearPath(fromRow, fromCol, toRow, toCol) {
                const dr = Math.sign(toRow - fromRow);
                const dc = Math.sign(toCol - fromCol);
                const dist = Math.max(Math.abs(toRow - fromRow), Math.abs(toCol - fromCol));
                
                for (let i = 1; i < dist; i++) {
                    const checkRow = fromRow + dr * i;
                    const checkCol = fromCol + dc * i;
                    if (this.board[checkRow][checkCol]) {
                        return false;
                    }
                }
                return true;
            }

            // é§’ã‚’æ‰“ã¦ã‚‹ã‹
            canDrop(piece, row, col) {
                // äºŒæ­©ãƒã‚§ãƒƒã‚¯
                if (piece === 'æ­©') {
                    for (let r = 0; r < 9; r++) {
                        if (this.board[r][col] && 
                            this.board[r][col].piece === 'æ­©' && 
                            this.board[r][col].side === 'sente') {
                            return false;
                        }
                    }
                }
                
                // è¡Œãæ‰€ãƒã‚§ãƒƒã‚¯
                if ((piece === 'æ­©' || piece === 'é¦™') && row === 0) return false;
                if (piece === 'æ¡‚' && row <= 1) return false;
                
                return true;
            }

            // å¾Œæ‰‹ãŒé§’ã‚’æ‰“ã¦ã‚‹ã‹
            canDropGote(piece, row, col) {
                // äºŒæ­©ãƒã‚§ãƒƒã‚¯
                if (piece === 'æ­©') {
                    for (let r = 0; r < 9; r++) {
                        if (this.board[r][col] && 
                            this.board[r][col].piece === 'æ­©' && 
                            this.board[r][col].side === 'gote') {
                            return false;
                        }
                    }
                }
                
                // è¡Œãæ‰€ãƒã‚§ãƒƒã‚¯ï¼ˆå¾Œæ‰‹ãªã®ã§é€†æ–¹å‘ï¼‰
                if ((piece === 'æ­©' || piece === 'é¦™') && row === 8) return false;
                if (piece === 'æ¡‚' && row >= 7) return false;
                
                return true;
            }

            // å¾Œæ‰‹ãŒã“ã®é§’ã‚’æŒé§’ã¨ã—ã¦ä½¿ãˆã‚‹ã‹
            canGoteUsePiece(piece) {
                // è©°å°†æ£‹ã§ã¯å…ˆæ‰‹ã®æŒé§’ä»¥å¤–ã¯å…¨ã¦å¾Œæ‰‹ãŒæŒã£ã¦ã„ã‚‹
                // ãŸã ã—ã€ç›¤ä¸Šã«ã‚ã‚‹é§’ã®æ•°ã‚’è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                
                // å„é§’ã®æœ€å¤§æšæ•°
                const maxPieces = {
                    'é£›': 2, 'è§’': 2, 'é‡‘': 4, 'éŠ€': 4,
                    'æ¡‚': 4, 'é¦™': 4, 'æ­©': 18
                };
                
                // ç›¤ä¸Šã«ã‚ã‚‹é§’ã‚’æ•°ãˆã‚‹
                let boardCount = 0;
                let senteHandCount = this.mochiGoma.sente[piece] || 0;
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const p = this.board[row][col];
                        if (p) {
                            // æˆé§’ã‚’å…ƒã®é§’ã«æˆ»ã—ã¦æ•°ãˆã‚‹
                            const demoted = this.demotePiece(p.piece);
                            if (demoted === piece) {
                                boardCount++;
                            }
                        }
                    }
                }
                
                // å¾Œæ‰‹ãŒä½¿ãˆã‚‹é§’æ•° = æœ€å¤§æ•° - ç›¤ä¸Šã®æ•° - å…ˆæ‰‹ã®æŒé§’æ•°
                const available = maxPieces[piece] - boardCount - senteHandCount;
                
                if (this.debugMode && available > 0) {
                    this.debugLog(`      å¾Œæ‰‹ã¯${piece}ã‚’æŒé§’ã¨ã—ã¦ä½¿ãˆã‚‹ (æœ€å¤§:${maxPieces[piece]} ç›¤ä¸Š:${boardCount} å…ˆæ‰‹æŒ:${senteHandCount} â†’ ä½¿ç”¨å¯èƒ½:${available})`);
                }
                
                return available > 0;
            }

            // åˆé§’ãŒæœ‰åŠ¹ã‹ã©ã†ã‹åˆ¤å®š
            isValidAigoma(piece, row, col, attackers) {
                // æ”»æ’ƒè€…ãŒ0ãªã‚‰åˆé§’ã®å¿…è¦ãªã—
                if (attackers.length === 0) return false;
                
                // æ”»æ’ƒè€…ãŒ2ã¤ä»¥ä¸Šãªã‚‰ä¸¡åŠ¹ãã§åˆé§’ç„¡åŠ¹
                if (attackers.length >= 2) return false;
                
                // 1ã¤ã®æ”»æ’ƒè€…ã®å ´åˆã€åˆé§’ã‚’è©¦ã—ã¦ã¿ã‚‹
                const testMove = {
                    type: 'drop',
                    piece: piece,
                    to: internalToHuman(row, col),
                    side: 'gote'
                };
                
                // åˆé§’ã‚’å®Ÿè¡Œ
                const backup = this.makeMove(testMove);
                
                // åˆé§’å¾Œã‚‚ç‹æ‰‹ãŒç¶šãã‹ç¢ºèª
                const stillInCheck = this.isCheck('gote');
                
                // åˆé§’ã‚’æˆ»ã™
                this.unmakeMove(testMove, backup);
                
                // åˆé§’å¾Œã«ç‹æ‰‹ãŒè§£é™¤ã•ã‚Œã‚Œã°æœ‰åŠ¹
                return !stillInCheck;
            }

            // æˆã‚Šåˆ¤å®š
            canPromote(piece, fromRow, toRow, side) {
                if (piece === 'é‡‘' || piece === 'ç‰' || 
                    piece === 'ã¨' || piece === 'æ' || piece === 'åœ­' || 
                    piece === 'å…¨' || piece === 'é¦¬' || piece === 'é¾') {
                    return false;
                }
                
                if (side === 'sente') {
                    return fromRow <= 2 || toRow <= 2;
                } else {
                    return fromRow >= 6 || toRow >= 6;
                }
            }
            
            // å¿…ãšæˆã‚‰ãªã‘ã‚Œã°ãªã‚‰ãªã„ã‹åˆ¤å®š
            mustPromote(piece, fromRow, toRow, side) {
                if (side === 'sente') {
                    // æ­©ãƒ»é¦™è»Šã¯ï¼‘æ®µç›®ã€æ¡‚é¦¬ã¯ï¼‘ãƒ»ï¼’æ®µç›®ã§å¿…ãšæˆã‚‹
                    if ((piece === 'æ­©' || piece === 'é¦™') && toRow === 0) return true;
                    if (piece === 'æ¡‚' && toRow <= 1) return true;
                } else {
                    // æ­©ãƒ»é¦™è»Šã¯ï¼™æ®µç›®ã€æ¡‚é¦¬ã¯ï¼˜ãƒ»ï¼™æ®µç›®ã§å¿…ãšæˆã‚‹
                    if ((piece === 'æ­©' || piece === 'é¦™') && toRow === 8) return true;
                    if (piece === 'æ¡‚' && toRow >= 7) return true;
                }
                return false;
            }

            // é§’ã‚’æˆã‚‹
            promotePiece(piece) {
                const promoteMap = {
                    'æ­©': 'ã¨', 'é¦™': 'æ', 'æ¡‚': 'åœ­', 'éŠ€': 'å…¨',
                    'è§’': 'é¦¬', 'é£›': 'é¾'
                };
                return promoteMap[piece] || piece;
            }

            // é§’ã‚’æˆ»ã™
            demotePiece(piece) {
                const demoteMap = {
                    'ã¨': 'æ­©', 'æ': 'é¦™', 'åœ­': 'æ¡‚', 'å…¨': 'éŠ€',
                    'é¦¬': 'è§’', 'é¾': 'é£›'
                };
                return demoteMap[piece] || piece;
            }

            // æ‰‹ã®è¡¨ç¤º
            formatMove(move) {
                const sideSymbol = move.side === 'gote' ? 'â–³' : 'â–²';
                
                if (move.type === 'drop') {
                    return `${sideSymbol}${move.to}${move.piece}æ‰“`;
                } else {
                    const capture = move.captured ? 'Ã—' : '';
                    
                    // å…ƒã®é§’ç¨®ã‚’åˆ¤å®šï¼ˆæˆé§’ã®å ´åˆã¯å…ƒã«æˆ»ã™ï¼‰
                    let originalPiece = move.piece;
                    if (['é¾', 'é¦¬', 'ã¨', 'æ', 'åœ­', 'å…¨'].includes(move.piece)) {
                        originalPiece = this.demotePiece(move.piece);
                    }
                    
                    // æˆã‚‹å ´åˆã¯å…ƒã®é§’å+æˆã€æˆã‚‰ãªã„å ´åˆã¯é§’åã®ã¿
                    if (move.promote) {
                        return `${sideSymbol}${move.to}${originalPiece}æˆ${capture}(${move.from})`;
                    } else {
                        return `${sideSymbol}${move.to}${move.piece}${capture}(${move.from})`;
                    }
                }
            }

            // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
            isInBoard(row, col) {
                return row >= 0 && row < 9 && col >= 0 && col < 9;
            }

            // ç›¤é¢ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
            validateBoard() {
                try {
                    let senteKingCount = 0;
                    let goteKingCount = 0;
                    const pieceCounts = {};
                    const pawnColumns = { sente: new Set(), gote: new Set() };
                    
                    // ç›¤ä¸Šã®é§’ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
                    for (let row = 0; row < 9; row++) {
                        for (let col = 0; col < 9; col++) {
                            const piece = this.board[row][col];
                            if (!piece) continue;
                            
                            // ç‰ã®ã‚«ã‚¦ãƒ³ãƒˆ
                            if (piece.piece === 'ç‰') {
                                if (piece.side === 'sente') senteKingCount++;
                                else goteKingCount++;
                            }
                            
                            // é§’ç¨®åˆ¥ã‚«ã‚¦ãƒ³ãƒˆ
                            const demoted = this.demotePiece(piece.piece);
                            const key = `${demoted}_${piece.side}`;
                            pieceCounts[key] = (pieceCounts[key] || 0) + 1;
                            
                            // äºŒæ­©ãƒã‚§ãƒƒã‚¯ç”¨
                            if (piece.piece === 'æ­©') {
                                if (pawnColumns[piece.side].has(col)) {
                                    return { valid: false, message: `${piece.side === 'sente' ? 'å…ˆæ‰‹' : 'å¾Œæ‰‹'}ã®äºŒæ­©ãŒã‚ã‚Šã¾ã™ï¼ˆ${col + 1}ç­‹ï¼‰` };
                                }
                                pawnColumns[piece.side].add(col);
                            }
                            
                            // è¡Œãæ‰€ã®ãªã„é§’ãƒã‚§ãƒƒã‚¯
                            if (piece.side === 'sente') {
                                if ((piece.piece === 'æ­©' || piece.piece === 'é¦™') && row === 0) {
                                    return { valid: false, message: `è¡Œãæ‰€ã®ãªã„${piece.piece}ãŒã‚ã‚Šã¾ã™ï¼ˆ${internalToHuman(row, col)}ï¼‰` };
                                }
                                if (piece.piece === 'æ¡‚' && row <= 1) {
                                    return { valid: false, message: `è¡Œãæ‰€ã®ãªã„æ¡‚ãŒã‚ã‚Šã¾ã™ï¼ˆ${internalToHuman(row, col)}ï¼‰` };
                                }
                            } else {
                                if ((piece.piece === 'æ­©' || piece.piece === 'é¦™') && row === 8) {
                                    return { valid: false, message: `è¡Œãæ‰€ã®ãªã„${piece.piece}ãŒã‚ã‚Šã¾ã™ï¼ˆ${internalToHuman(row, col)}ï¼‰` };
                                }
                                if (piece.piece === 'æ¡‚' && row >= 7) {
                                    return { valid: false, message: `è¡Œãæ‰€ã®ãªã„æ¡‚ãŒã‚ã‚Šã¾ã™ï¼ˆ${internalToHuman(row, col)}ï¼‰` };
                                }
                            }
                        }
                    }
                    
                    // ç‰ã®ãƒã‚§ãƒƒã‚¯
                    if (senteKingCount > 1) {
                        return { valid: false, message: 'å…ˆæ‰‹ã®ç‰ãŒè¤‡æ•°ã‚ã‚Šã¾ã™' };
                    }
                    if (goteKingCount === 0) {
                        return { valid: false, message: 'å¾Œæ‰‹ã®ç‰ãŒã‚ã‚Šã¾ã›ã‚“' };
                    }
                    if (goteKingCount > 1) {
                        return { valid: false, message: 'å¾Œæ‰‹ã®ç‰ãŒè¤‡æ•°ã‚ã‚Šã¾ã™' };
                    }
                    
                    // é§’æ•°ã®ä¸Šé™ãƒã‚§ãƒƒã‚¯
                    const maxPieces = {
                        'é£›': 2, 'è§’': 2, 'é‡‘': 4, 'éŠ€': 4,
                        'æ¡‚': 4, 'é¦™': 4, 'æ­©': 18
                    };
                    
                    for (const [piece, maxCount] of Object.entries(maxPieces)) {
                        const totalCount = (pieceCounts[`${piece}_sente`] || 0) + 
                                         (pieceCounts[`${piece}_gote`] || 0) +
                                         (this.mochiGoma.sente[piece] || 0);
                        
                        if (totalCount > maxCount) {
                            return { valid: false, message: `${piece}ã®æ•°ãŒå¤šã™ãã¾ã™ï¼ˆ${totalCount}æš / æœ€å¤§${maxCount}æšï¼‰` };
                        }
                    }
                    
                    // å…ˆæ‰‹ç‰ãŒç‹æ‰‹ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆè©°å°†æ£‹ã§ã¯å…ˆæ‰‹ç‰ã¯ç‹æ‰‹ã•ã‚Œã¦ã„ã¦ã¯ã„ã‘ãªã„ï¼‰
                    if (senteKingCount === 1 && this.isCheck('sente')) {
                        return { valid: false, message: 'å…ˆæ‰‹ç‰ãŒç‹æ‰‹ã•ã‚Œã¦ã„ã¾ã™ï¼ˆè©°å°†æ£‹ã§ã¯ç„¡åŠ¹ï¼‰' };
                    }
                    
                    return { valid: true };
                    
                } catch (error) {
                    console.error('ç›¤é¢æ¤œè¨¼ã‚¨ãƒ©ãƒ¼:', error);
                    return { valid: false, message: ' ç›¤é¢ã®æ¤œè¨¼ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ' };
                }
            }

            // æ‰‹ã®ä¸¦ã³æ›¿ãˆï¼ˆè‰¯ã„æ‰‹ã‚’å„ªå…ˆï¼‰
            orderMoves(moves, depth) {
                // å„æ‰‹ã«ã‚¹ã‚³ã‚¢ã‚’ä»˜ã‘ã‚‹
                const scoredMoves = moves.map(move => {
                    let score = 0;
                    
                    // ã‚­ãƒ©ãƒ¼ãƒ ãƒ¼ãƒ–ãƒœãƒ¼ãƒŠã‚¹
                    const killerKey = `${depth}_${this.formatMove(move)}`;
                    if (this.killerMoves.has(killerKey)) {
                        score += 1000;
                    }
                    
                    // é§’ã‚’å–ã‚‹æ‰‹ã‚’å„ªå…ˆ
                    if (move.captured) {
                        score += 500;
                        // ä¾¡å€¤ã®é«˜ã„é§’ã‚’å–ã‚‹æ‰‹ã‚’ã•ã‚‰ã«å„ªå…ˆ
                        const pieceValues = {
                            'é£›': 100, 'é¾': 110, 'è§’': 90, 'é¦¬': 95,
                            'é‡‘': 60, 'éŠ€': 50, 'æ¡‚': 40, 'é¦™': 30, 'æ­©': 10
                        };
                        score += pieceValues[move.captured.piece] || 0;
                    }
                    
                    // é§’æ‰“ã¡ã‚ˆã‚Šç§»å‹•ã‚’å„ªå…ˆï¼ˆä¸€èˆ¬çš„ã«ç§»å‹•ã®æ–¹ãŒå¼·ã„ï¼‰
                    if (move.type === 'move') {
                        score += 20;
                    }
                    
                    // æˆã‚‹æ‰‹ã‚’å„ªå…ˆ
                    if (move.promote) {
                        score += 30;
                    }
                    
                    // ãƒ’ã‚¹ãƒˆãƒªãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã‚¹ã‚³ã‚¢
                    const histKey = this.formatMove(move);
                    if (this.historyTable.has(histKey)) {
                        score += this.historyTable.get(histKey);
                    }
                    
                    return { move, score };
                });
                
                // ã‚¹ã‚³ã‚¢ã®é«˜ã„é †ã«ã‚½ãƒ¼ãƒˆ
                scoredMoves.sort((a, b) => b.score - a.score);
                
                return scoredMoves.map(sm => sm.move);
            }

            // ã‚­ãƒ©ãƒ¼ãƒ ãƒ¼ãƒ–ã‚’è¨˜éŒ²
            recordKillerMove(depth, move) {
                const key = `${depth}_${this.formatMove(move)}`;
                this.killerMoves.set(key, true);
                
                // å¤ã„ã‚­ãƒ©ãƒ¼ãƒ ãƒ¼ãƒ–ã‚’å‰Šé™¤ï¼ˆãƒ¡ãƒ¢ãƒªç¯€ç´„ï¼‰
                if (this.killerMoves.size > 1000) {
                    const firstKey = this.killerMoves.keys().next().value;
                    this.killerMoves.delete(firstKey);
                }
            }

            displayMoves(moves) {
                const moveList = document.getElementById('moveList');
                moveList.style.display = 'block';
                moveList.innerHTML = '<h3>è©°ã¿æ‰‹é †</h3>';
                
                moves.forEach((move, index) => {
                    const moveItem = document.createElement('div');
                    moveItem.className = 'move-item';
                    moveItem.textContent = `${index + 1}. ${move}`;
                    moveList.appendChild(moveItem);
                });
            }

            updateStatus(message, type = '') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = 'status ' + type;
            }

            clearBoard() {
                this.board = Array(9).fill(null).map(() => Array(9).fill(null));
                this.mochiGoma = { sente: {}, gote: {} };
                this.updateBoard();
                this.updateMochiGomaDisplay();
                this.updateStatus('ç›¤é¢ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
                document.getElementById('moveList').style.display = 'none';
                document.getElementById('stats').innerHTML = '';
            }
            
            updateMochiGomaDisplay() {
                const senteMochi = document.getElementById('senteMochi');
                
                const formatMochi = (mochi) => {
                    if (Object.keys(mochi).length === 0) return 'ãªã—';
                    return Object.entries(mochi)
                        .map(([piece, count]) => `${piece}${count > 1 ? count : ''}`)
                        .join(' ');
                };
                
                senteMochi.textContent = formatMochi(this.mochiGoma.sente);
            }

            getProblemList() {
                return [
                    {
                        name: '1æ‰‹è©°ã‚ï¼ˆåŸºæœ¬ï¼‰',
                        position: 'â–³ï¼•ä¸€ç‰ â–²ï¼–äºŒé‡‘ â–²ï¼•äºŒé‡‘',
                        description: 'â–²ï¼”äºŒé‡‘ã§è©°ã¿'
                    },
                    {
                        name: '3æ‰‹è©°ã‚ï¼ˆæŒé§’ä½¿ç”¨ï¼‰',
                        position: 'â–³ï¼•äºŒç‰ â–³ï¼”äºŒæ­© â–²ï¼•äº”é£› â–²æŒé‡‘1',
                        description: 'â–²ï¼•ä¸‰é‡‘æ‰“ã‹ã‚‰è©°ã¿'
                    },
                    {
                        name: '3æ‰‹è©°ã‚ï¼ˆåˆé§’å•é¡Œï¼‰',
                        position: 'â–³ï¼”ä¸€ç‰ â–³ï¼”äºŒæ­© â–²ï¼’äºŒé£› â–²ï¼•ä¸‰æ­© â–²æŒéŠ€1',
                        description: 'â–²ï¼’ä¸€é£›æˆâ†’â–³ï¼“ä¸€æ­©åˆâ†’â–²ï¼•äºŒéŠ€æ‰“ã§è©°ã¿'
                    },
                    {
                        name: 'ä¸è©°ã¿ï¼ˆåˆé§’ã§é€ƒã‚Œã‚‹ï¼‰',
                        position: 'â–³ï¼’äºŒç‰ â–³ï¼’ä¸€éŠ€ â–³ï¼’ä¸‰æ­© â–³ï¼‘ä¸‰æ­© â–²ï¼”å››é¾ â–²ï¼•äº”è§’',
                        description: 'åˆé§’ã§é€ƒã‚Œã¦ä¸è©°ã¿'
                    },
                    {
                        name: '1æ‰‹è©°ã‚ï¼ˆé ­é‡‘ï¼‰',
                        position: 'â–³ï¼‘äºŒç‰ â–³ï¼‘ä¸‰æ­© â–²ï¼’äºŒé‡‘ â–²ï¼’å››æ­©',
                        description: 'â–²ï¼‘ä¸‰é‡‘ã§è©°ã¿'
                    },
                    {
                        name: '3æ‰‹è©°ã‚ï¼ˆé£›è»Šã®åˆ©ãï¼‰',
                        position: 'â–³ï¼‘ä¸€ç‰ â–³ï¼’ä¸€é‡‘ â–²ï¼‘ä¸‰é£› â–²æŒé‡‘1',
                        description: 'â–²ï¼’äºŒé‡‘æ‰“ã‹ã‚‰è©°ã¿'
                    }
                ];
            }
            
            loadSampleProblem() {
                const problems = this.getProblemList();
                
                // ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
                const problem = problems[Math.floor(Math.random() * problems.length)];
                
                this.clearBoard();
                this.decodePosition(problem.position);
                this.updateBoard();
                this.updateMochiGomaDisplay();
                this.updateStatus(`ä¾‹é¡Œã€Œ${problem.name}ã€ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ - ${problem.description}`);
            }
            
            loadSpecificProblem(index) {
                const problems = this.getProblemList();
                
                if (index >= 0 && index < problems.length) {
                    const problem = problems[index];
                    
                    this.clearBoard();
                    this.decodePosition(problem.position);
                    this.updateBoard();
                    this.updateMochiGomaDisplay();
                    this.updateStatus(`ä¾‹é¡Œã€Œ${problem.name}ã€ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ - ${problem.description}`);
                } else {
                    this.updateStatus('ç„¡åŠ¹ãªä¾‹é¡Œç•ªå·ã§ã™', 'error');
                }
            }

            // é…ç½®ã‚’æ–‡å­—åˆ—ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
            encodePosition() {
                const pieces = [];
                
                // ç›¤ä¸Šã®é§’
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            const pos = internalToHuman(row, col);
                            const prefix = piece.side === 'gote' ? 'â–³' : 'â–²';
                            pieces.push(`${prefix}${pos}${piece.piece}`);
                        }
                    }
                }
                
                // æŒã¡é§’
                for (const [piece, count] of Object.entries(this.mochiGoma.sente)) {
                    if (count > 0) {
                        pieces.push(`â–²æŒ${piece}${count > 1 ? count : ''}`);
                    }
                }
                
                return pieces.join(' ');
            }

            // æ–‡å­—åˆ—ã‹ã‚‰é…ç½®ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰
            decodePosition(code) {
                console.log('ãƒ‡ã‚³ãƒ¼ãƒ‰é–‹å§‹:', code);
                this.clearBoard();
                
                // ã‚¹ãƒšãƒ¼ã‚¹ã¾ãŸã¯ã‚«ãƒ³ãƒã§åˆ†å‰²
                const parts = code.trim().split(/[\s,]+/);
                console.log('åˆ†å‰²ã•ã‚ŒãŸãƒ‘ãƒ¼ãƒ„:', parts);
                
                for (const part of parts) {
                    if (part.length < 3) {
                        console.log('ã‚¹ã‚­ãƒƒãƒ—ï¼ˆçŸ­ã™ãã‚‹ï¼‰:', part);
                        continue;
                    }
                    
                    const prefix = part[0];
                    const side = prefix === 'â–³' ? 'gote' : 'sente';
                    
                    if (part.includes('æŒ')) {
                        // æŒã¡é§’
                        const match = part.match(/æŒ(.+?)(\d*)$/);
                        if (match) {
                            const piece = match[1];
                            const count = match[2] ? parseInt(match[2]) : 1;
                            console.log(`æŒã¡é§’: ${piece} x ${count}`);
                            this.mochiGoma.sente[piece] = count;
                        }
                    } else {
                        // ç›¤ä¸Šã®é§’
                        const pos = part.substring(1, 3);
                        const piece = part.substring(3);
                        console.log(`ç›¤ä¸Š: ${pos} ã« ${side} ã® ${piece}`);
                        
                        const coords = humanToInternal(pos);
                        if (coords) {
                            const [row, col] = coords;
                            this.board[row][col] = { piece, side };
                        } else {
                            console.error('åº§æ¨™å¤‰æ›å¤±æ•—:', pos);
                        }
                    }
                }
                
                this.updateBoard();
                this.updateMochiGomaDisplay();
                console.log('ãƒ‡ã‚³ãƒ¼ãƒ‰å®Œäº†');
            }

            // é…ç½®ã‚’ä¿å­˜
            saveToLocalStorage(name) {
                const saved = this.getSavedPositions();
                saved[name] = {
                    code: this.encodePosition(),
                    date: new Date().toLocaleString('ja-JP')
                };
                localStorage.setItem('tsumePositions', JSON.stringify(saved));
            }

            // ä¿å­˜ã—ãŸé…ç½®ã‚’å–å¾—
            getSavedPositions() {
                const saved = localStorage.getItem('tsumePositions');
                return saved ? JSON.parse(saved) : {};
            }

            // é…ç½®ã‚’å‰Šé™¤
            deleteFromLocalStorage(name) {
                const saved = this.getSavedPositions();
                delete saved[name];
                localStorage.setItem('tsumePositions', JSON.stringify(saved));
            }
        }

        // ã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–
        const engine = new TsumeShogi();

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°
        function solveTsume() {
            engine.solveTsume();
        }

        function clearBoard() {
            engine.clearBoard();
        }

        function loadSampleProblem() {
            engine.loadSampleProblem();
        }
        
        function loadSpecificProblem() {
            const select = document.getElementById('problemSelect');
            const index = parseInt(select.value);
            if (!isNaN(index)) {
                engine.loadSpecificProblem(index);
            } else {
                engine.updateStatus('ä¾‹é¡Œã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
            }
        }
        
        function addMochiGoma() {
            const select = document.getElementById('mochiPiece');
            const piece = select.value;
            if (!piece) return;
            
            if (!engine.mochiGoma.sente[piece]) {
                engine.mochiGoma.sente[piece] = 0;
            }
            engine.mochiGoma.sente[piece]++;
            engine.updateMochiGomaDisplay();
            select.value = '';
        }
        
        function clearSenteMochi() {
            engine.mochiGoma.sente = {};
            engine.updateMochiGomaDisplay();
        }

        // é…ç½®ã®ä¿å­˜ãƒ»èª­è¾¼æ©Ÿèƒ½
        function savePosition() {
            const name = prompt('é…ç½®ã®åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š');
            if (name && name.trim()) {
                engine.saveToLocalStorage(name.trim());
                engine.updateStatus(`ã€Œ${name}ã€ã¨ã—ã¦ä¿å­˜ã—ã¾ã—ãŸ`);
                updatePositionSelect();
            }
        }

        function showSavedPositions() {
            const div = document.getElementById('savedPositions');
            div.style.display = div.style.display === 'none' ? 'block' : 'none';
            if (div.style.display === 'block') {
                updatePositionSelect();
            }
        }

        function updatePositionSelect() {
            const select = document.getElementById('positionSelect');
            const saved = engine.getSavedPositions();
            
            select.innerHTML = '<option value="">ä¿å­˜ã—ãŸé…ç½®ã‚’é¸æŠ</option>';
            
            for (const [name, data] of Object.entries(saved)) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = `${name} (${data.date})`;
                select.appendChild(option);
            }
        }

        function loadPosition() {
            const select = document.getElementById('positionSelect');
            const name = select.value;
            if (!name) {
                engine.updateStatus('é…ç½®ã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            const saved = engine.getSavedPositions();
            console.log('ä¿å­˜ã•ã‚ŒãŸé…ç½®ä¸€è¦§:', saved);
            console.log('é¸æŠã•ã‚ŒãŸé…ç½®å:', name);
            
            if (saved[name]) {
                console.log('èª­ã¿è¾¼ã‚€é…ç½®ã‚³ãƒ¼ãƒ‰:', saved[name].code);
                try {
                    engine.decodePosition(saved[name].code);
                    engine.updateStatus(`ã€Œ${name}ã€ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
                } catch (error) {
                    console.error('é…ç½®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    engine.updateStatus('é…ç½®ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
                }
            } else {
                engine.updateStatus('æŒ‡å®šã•ã‚ŒãŸé…ç½®ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'error');
            }
        }

        function deletePosition() {
            const select = document.getElementById('positionSelect');
            const name = select.value;
            if (!name) return;
            
            if (confirm(`ã€Œ${name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
                engine.deleteFromLocalStorage(name);
                updatePositionSelect();
                engine.updateStatus(`ã€Œ${name}ã€ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`);
            }
        }

        function exportPosition() {
            const code = engine.encodePosition();
            const textarea = document.getElementById('positionCode');
            textarea.value = code;
            
            // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
            textarea.select();
            document.execCommand('copy');
            
            engine.updateStatus('é…ç½®ã‚³ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
        }

        function importPosition() {
            const textarea = document.getElementById('positionCode');
            const code = textarea.value.trim();
            
            if (code) {
                try {
                    engine.decodePosition(code);
                    engine.updateStatus('é…ç½®ã‚³ãƒ¼ãƒ‰ã‹ã‚‰èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
                } catch (error) {
                    console.error('é…ç½®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    engine.updateStatus('é…ç½®ã‚³ãƒ¼ãƒ‰ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“', 'error');
                }
            }
        }

        function toggleDebugMode() {
            const checkbox = document.getElementById('debugMode');
            const debugOutput = document.getElementById('debugOutput');
            engine.debugMode = checkbox.checked;
            debugOutput.style.display = checkbox.checked ? 'block' : 'none';
            
            if (checkbox.checked) {
                engine.updateStatus('ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹');
            } else {
                engine.updateStatus('ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ç„¡åŠ¹');
                debugOutput.innerHTML = '';
            }
        }

        // ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ã‚’ã‚¨ãƒ³ã‚¸ãƒ³ã«è¿½åŠ 
        engine.debugLog = function(message) {
            if (this.debugMode) {
                const debugOutput = document.getElementById('debugOutput');
                const timestamp = new Date().toLocaleTimeString('ja-JP', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit'
                });
                debugOutput.innerHTML += `[${timestamp}] ${message}<br>`;
                debugOutput.scrollTop = debugOutput.scrollHeight;
                
                // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«ã‚‚å‡ºåŠ›
                console.log(`[DEBUG] ${message}`);
            }
        };
        
        // ç›¤é¢ã®ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
        engine.debugBoard = function() {
            if (!this.debugMode) return;
            
            let boardStr = '\n';
            boardStr += '  ï¼™ ï¼˜ ï¼— ï¼– ï¼• ï¼” ï¼“ ï¼’ ï¼‘\n';
            boardStr += '+--+--+--+--+--+--+--+--+--+\n';
            
            for (let row = 0; row < 9; row++) {
                boardStr += DAN_STR[row] + '|';
                for (let col = 0; col < 9; col++) {
                    const piece = this.board[row][col];
                    if (piece) {
                        const prefix = piece.side === 'gote' ? 'â–³' : 'â–²';
                        boardStr += prefix + piece.piece;
                    } else {
                        boardStr += '  ';
                    }
                    boardStr += '|';
                }
                boardStr += '\n';
            }
            boardStr += '+--+--+--+--+--+--+--+--+--+\n';
            
            // æŒã¡é§’
            const formatMochi = (mochi) => {
                if (Object.keys(mochi).length === 0) return 'ãªã—';
                return Object.entries(mochi)
                    .map(([piece, count]) => `${piece}${count > 1 ? count : ''}`)
                    .join(' ');
            };
            boardStr += `å…ˆæ‰‹æŒé§’: ${formatMochi(this.mochiGoma.sente)}\n`;
            
            this.debugLog(boardStr);
        };
    </script>
</body>
</html>